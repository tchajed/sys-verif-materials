(* autogenerated from sys_verif_code/algo *)
From New.golang Require Import defn.
Module pkg_id.
Definition algo : go_string := "sys_verif_code/algo".

End pkg_id.
Export pkg_id.
Module algo.

Definition Person {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/algo.Person"%go [].

Definition Sort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/algo.Sort"%go.

(* Sort sorts arr by increasing Age.

   go: sort.go:9:6 *)
Definition Sortⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "arr",
    exception_do (let: "arr" := (GoAlloc (go.SliceType Person) "arr") in
    let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Person] "arr") in
    (FuncResolve go.len [go.SliceType Person] #()) "$a0")) in
    do:  ("l" <-[go.uint64] "$r0");;;
    let: "l_m_1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "l") -⟨go.uint64⟩ #(W64 1)) in
    do:  ("l_m_1" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "l")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "l_m_1")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Person "Age"%go (IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int (![go.uint64] "j"))))) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef Person "Age"%go (IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))))))
        then
          let: "tmp" := (GoAlloc Person (GoZeroVal Person #())) in
          let: "$r0" := (![Person] (IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int (![go.uint64] "j")))) in
          do:  ("tmp" <-[Person] "$r0");;;
          let: "$r0" := (![Person] (IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1))))) in
          do:  ((IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int (![go.uint64] "j"))) <-[Person] "$r0");;;
          let: "$r0" := (![Person] "tmp") in
          do:  ((IndexRef (go.SliceType Person) (![go.SliceType Person] "arr", Convert go.uint64 go.int ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) <-[Person] "$r0")
        else do:  #())))));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.algo :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.algo (λ: <>,
      exception_do (do:  #())
      ).

Module Person.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Name' : go_string;
  Age' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Person.

Definition Person'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Name"%go go.string);
  (go.FieldDecl "Age"%go go.uint64)
].
Program Definition Person'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Person'fds_unsealed).
Global Instance equals_unfold_Person {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Person'fds =→ Person'fds_unsealed.
Proof. rewrite /Person'fds seal_eq //. Qed.

Definition Personⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Person'fds).

Class Person_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Person_type_repr  :: go.TypeReprUnderlying Personⁱᵐᵖˡ Person.t;
  #[global] Person_underlying :: (Person) <u (Personⁱᵐᵖˡ);
  #[global] Person_get_Name (x : Person.t) :: ⟦StructFieldGet (Personⁱᵐᵖˡ) "Name", #x⟧ ⤳[under] #x.(Person.Name');
  #[global] Person_set_Name (x : Person.t) y :: ⟦StructFieldSet (Personⁱᵐᵖˡ) "Name", (#x, #y)⟧ ⤳[under] #(x <|Person.Name' := y|>);
  #[global] Person_get_Age (x : Person.t) :: ⟦StructFieldGet (Personⁱᵐᵖˡ) "Age", #x⟧ ⤳[under] #x.(Person.Age');
  #[global] Person_set_Age (x : Person.t) y :: ⟦StructFieldSet (Personⁱᵐᵖˡ) "Age", (#x, #y)⟧ ⤳[under] #(x <|Person.Age' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Person_instance :: Person_Assumptions;
  #[global] Sort_unfold :: FuncUnfold Sort [] (Sortⁱᵐᵖˡ);
}.
End algo.
