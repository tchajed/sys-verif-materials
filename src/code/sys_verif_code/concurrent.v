(* autogenerated from sys_verif_code/concurrent *)
Require Export New.code.sync.
Require Export New.code.sys_verif_code.concurrent.barrier.
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition concurrent : go_string := "sys_verif_code/concurrent".

End pkg_id.
Export pkg_id.
Module concurrent.

Definition AtomicInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/concurrent.AtomicInt"%go [].

Definition NewAtomicInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.NewAtomicInt"%go.

Definition ParallelAdd1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.ParallelAdd1"%go.

Definition ParallelAdd2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.ParallelAdd2"%go.

Definition ParallelAdd3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.ParallelAdd3"%go.

Definition ParallelAdd_Nthreads {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.ParallelAdd_Nthreads"%go.

Definition SetX {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.SetX"%go.

Definition NoGo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.NoGo"%go.

Definition FirstGo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.FirstGo"%go.

Definition FirstLock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.FirstLock"%go.

Definition LockedCounter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent.LockedCounter"%go.

(* go: concurrent.go:17:6 *)
Definition NewAtomicIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc AtomicInt (let: "$v0" := #(W64 0) in
     let: "$v1" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
     CompositeLiteral AtomicInt (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v1")])))).

(* go: concurrent.go:21:21 *)
Definition AtomicInt__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i" <>,
    exception_do (let: "i" := (GoAlloc (go.PointerType AtomicInt) "i") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AtomicInt "mu"%go (![go.PointerType AtomicInt] "i")))) #());;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef AtomicInt "x"%go (![go.PointerType AtomicInt] "i"))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AtomicInt "mu"%go (![go.PointerType AtomicInt] "i")))) #());;;
    return: (![go.uint64] "x")).

(* go: concurrent.go:28:21 *)
Definition AtomicInt__Incⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i" "y",
    exception_do (let: "i" := (GoAlloc (go.PointerType AtomicInt) "i") in
    let: "y" := (GoAlloc go.uint64 "y") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AtomicInt "mu"%go (![go.PointerType AtomicInt] "i")))) #());;;
    do:  ((StructFieldRef AtomicInt "x"%go (![go.PointerType AtomicInt] "i")) <-[go.uint64] ((![go.uint64] (StructFieldRef AtomicInt "x"%go (![go.PointerType AtomicInt] "i"))) +⟨go.uint64⟩ (![go.uint64] "y")));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AtomicInt "mu"%go (![go.PointerType AtomicInt] "i")))) #());;;
    return: #()).

(* go: concurrent.go:34:6 *)
Definition ParallelAdd1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc (go.PointerType AtomicInt) (GoZeroVal (go.PointerType AtomicInt) #())) in
    let: "$r0" := ((FuncResolve NewAtomicInt [] #()) #()) in
    do:  ("i" <-[go.PointerType AtomicInt] "$r0");;;
    let: "h1" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  (let: "$a0" := #(W64 2) in
      (MethodResolve (go.PointerType AtomicInt) "Inc"%go (![go.PointerType AtomicInt] "i")) "$a0");;;
      return: #())
      ) in
    (FuncResolve std.Spawn [] #()) "$a0") in
    do:  ("h1" <-[go.PointerType std.JoinHandle] "$r0");;;
    let: "h2" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  (let: "$a0" := #(W64 2) in
      (MethodResolve (go.PointerType AtomicInt) "Inc"%go (![go.PointerType AtomicInt] "i")) "$a0");;;
      return: #())
      ) in
    (FuncResolve std.Spawn [] #()) "$a0") in
    do:  ("h2" <-[go.PointerType std.JoinHandle] "$r0");;;
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] "h1")) #());;;
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] "h2")) #());;;
    return: ((MethodResolve (go.PointerType AtomicInt) "Get"%go (![go.PointerType AtomicInt] "i")) #())).

(* go: concurrent.go:47:6 *)
Definition ParallelAdd2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "b" := (GoAlloc (go.PointerType barrier.Barrier) (GoZeroVal (go.PointerType barrier.Barrier) #())) in
    let: "$r0" := ((FuncResolve barrier.New [] #()) #()) in
    do:  ("b" <-[go.PointerType barrier.Barrier] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType barrier.Barrier) "Add"%go (![go.PointerType barrier.Barrier] "b")) "$a0");;;
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType barrier.Barrier) "Add"%go (![go.PointerType barrier.Barrier] "b")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      let: "$r0" := (let: "$a0" := (![go.uint64] "x") in
      let: "$a1" := #(W64 2) in
      (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
      do:  ("x" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      do:  ((MethodResolve (go.PointerType barrier.Barrier) "Done"%go (![go.PointerType barrier.Barrier] "b")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      let: "$r0" := (let: "$a0" := (![go.uint64] "x") in
      let: "$a1" := #(W64 2) in
      (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
      do:  ("x" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      do:  ((MethodResolve (go.PointerType barrier.Barrier) "Done"%go (![go.PointerType barrier.Barrier] "b")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType barrier.Barrier) "Wait"%go (![go.PointerType barrier.Barrier] "b")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    let: "x_now" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "x") in
    do:  ("x_now" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (![go.uint64] "x_now")).

(* go: concurrent.go:73:6 *)
Definition ParallelAdd3ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    let: "h1" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)));;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      return: #())
      ) in
    (FuncResolve std.Spawn [] #()) "$a0") in
    do:  ("h1" <-[go.PointerType std.JoinHandle] "$r0");;;
    let: "h2" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)));;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      return: #())
      ) in
    (FuncResolve std.Spawn [] #()) "$a0") in
    do:  ("h2" <-[go.PointerType std.JoinHandle] "$r0");;;
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] "h1")) #());;;
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] "h2")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "i") in
    do:  ("y" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (![go.uint64] "y")).

(* go: concurrent.go:94:6 *)
Definition ParallelAdd_Nthreadsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    let: "handles" := (GoAlloc (go.SliceType (go.PointerType std.JoinHandle)) (GoZeroVal (go.SliceType (go.PointerType std.JoinHandle)) #())) in
    (let: "thread_i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("thread_i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "thread_i") <⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, do:  ("thread_i" <-[go.uint64] ((![go.uint64] "thread_i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "h" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
      let: "$r0" := (let: "$a0" := (λ: <>,
        exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
        let: "$r0" := (let: "$a0" := (![go.uint64] "i") in
        let: "$a1" := #(W64 2) in
        (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
        do:  ("i" <-[go.uint64] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
        return: #())
        ) in
      (FuncResolve std.Spawn [] #()) "$a0") in
      do:  ("h" <-[go.PointerType std.JoinHandle] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType std.JoinHandle)] "handles") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType std.JoinHandle] "h") in
      CompositeLiteral (go.SliceType (go.PointerType std.JoinHandle)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType std.JoinHandle) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType std.JoinHandle)] #()) "$a0" "$a1") in
      do:  ("handles" <-[go.SliceType (go.PointerType std.JoinHandle)] "$r0")));;;
    let: "$range" := (![go.SliceType (go.PointerType std.JoinHandle)] "handles") in
    (let: "h" := (GoAlloc (go.PointerType std.JoinHandle) (GoZeroVal (go.PointerType std.JoinHandle) #())) in
    slice.for_range (go.PointerType std.JoinHandle) "$range" (λ: "$key" "$value",
      do:  ("h" <-[go.PointerType std.JoinHandle] "$value");;;
      do:  "$key";;;
      do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] "h")) #())));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "i") in
    do:  ("y" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (![go.uint64] "y")).

(* go: examples.go:5:6 *)
Definition SetXⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType go.uint64) "x") in
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] "$r0");;;
    return: #()).

(* go: examples.go:9:6 *)
Definition NoGoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  (let: "$a0" := "x" in
    (FuncResolve SetX [] #()) "$a0");;;
    return: #()).

(* go: examples.go:14:6 *)
Definition FirstGoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := "x" in
      (FuncResolve SetX [] #()) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: examples.go:21:6 *)
Definition FirstLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "m" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go "m") #());;;
      let: "$r0" := #(W64 1) in
      do:  ("x" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go "m") #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go "m") #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "x") in
    do:  ("y" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go "m") #());;;
    return: (![go.uint64] "y")).

(* go: examples.go:35:6 *)
Definition LockedCounterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "counter" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("counter" <-[go.PointerType go.uint64] "$r0");;;
    let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      let: "$r0" := ((![go.uint64] (![go.PointerType go.uint64] "counter")) +⟨go.uint64⟩ #(W64 2)) in
      do:  ((![go.PointerType go.uint64] "counter") <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      let: "$r0" := ((![go.uint64] (![go.PointerType go.uint64] "counter")) +⟨go.uint64⟩ #(W64 2)) in
      do:  ((![go.PointerType go.uint64] "counter") <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "counter")) in
    do:  ("y" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (![go.uint64] "y")).

#[global] Instance info' : PkgInfo pkg_id.concurrent :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.sys_verif_code.concurrent.barrier.pkg_id.barrier; code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.concurrent (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (barrier.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module AtomicInt.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
  mu' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End AtomicInt.

Definition AtomicInt'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex))
].
Program Definition AtomicInt'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (AtomicInt'fds_unsealed).
Global Instance equals_unfold_AtomicInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : AtomicInt'fds =→ AtomicInt'fds_unsealed.
Proof. rewrite /AtomicInt'fds seal_eq //. Qed.

Definition AtomicIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (AtomicInt'fds).

Class AtomicInt_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AtomicInt_type_repr  :: go.TypeReprUnderlying AtomicIntⁱᵐᵖˡ AtomicInt.t;
  #[global] AtomicInt_underlying :: (AtomicInt) <u (AtomicIntⁱᵐᵖˡ);
  #[global] AtomicInt_get_x (x : AtomicInt.t) :: ⟦StructFieldGet (AtomicIntⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(AtomicInt.x');
  #[global] AtomicInt_set_x (x : AtomicInt.t) y :: ⟦StructFieldSet (AtomicIntⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|AtomicInt.x' := y|>);
  #[global] AtomicInt_get_mu (x : AtomicInt.t) :: ⟦StructFieldGet (AtomicIntⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(AtomicInt.mu');
  #[global] AtomicInt_set_mu (x : AtomicInt.t) y :: ⟦StructFieldSet (AtomicIntⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|AtomicInt.mu' := y|>);
  #[global] AtomicInt'ptr_Get_unfold :: MethodUnfold (go.PointerType (AtomicInt)) "Get" (AtomicInt__Getⁱᵐᵖˡ);
  #[global] AtomicInt'ptr_Inc_unfold :: MethodUnfold (go.PointerType (AtomicInt)) "Inc" (AtomicInt__Incⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AtomicInt_instance :: AtomicInt_Assumptions;
  #[global] NewAtomicInt_unfold :: FuncUnfold NewAtomicInt [] (NewAtomicIntⁱᵐᵖˡ);
  #[global] ParallelAdd1_unfold :: FuncUnfold ParallelAdd1 [] (ParallelAdd1ⁱᵐᵖˡ);
  #[global] ParallelAdd2_unfold :: FuncUnfold ParallelAdd2 [] (ParallelAdd2ⁱᵐᵖˡ);
  #[global] ParallelAdd3_unfold :: FuncUnfold ParallelAdd3 [] (ParallelAdd3ⁱᵐᵖˡ);
  #[global] ParallelAdd_Nthreads_unfold :: FuncUnfold ParallelAdd_Nthreads [] (ParallelAdd_Nthreadsⁱᵐᵖˡ);
  #[global] SetX_unfold :: FuncUnfold SetX [] (SetXⁱᵐᵖˡ);
  #[global] NoGo_unfold :: FuncUnfold NoGo [] (NoGoⁱᵐᵖˡ);
  #[global] FirstGo_unfold :: FuncUnfold FirstGo [] (FirstGoⁱᵐᵖˡ);
  #[global] FirstLock_unfold :: FuncUnfold FirstLock [] (FirstLockⁱᵐᵖˡ);
  #[global] LockedCounter_unfold :: FuncUnfold LockedCounter [] (LockedCounterⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_barrier_Assumption :: barrier.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
}.
End concurrent.
