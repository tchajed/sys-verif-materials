(* autogenerated from sys_verif_code/concurrent/barrier *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition barrier : go_string := "sys_verif_code/concurrent/barrier".

End pkg_id.
Export pkg_id.
Module barrier.

Definition Barrier {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/concurrent/barrier.Barrier"%go [].

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/concurrent/barrier.New"%go.

(* Create a new barrier waiting for no threads.

   go: barrier.go:26:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
    return: (GoAlloc Barrier (let: "$v0" := #(W64 0) in
     let: "$v1" := (![go.PointerType sync.Mutex] "mu") in
     let: "$v2" := (![go.PointerType sync.Cond] "cond") in
     CompositeLiteral Barrier (LiteralValue [KeyedElement (Some (KeyField "numWaiting"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v1"); KeyedElement (Some (KeyField "cond"%go)) (ElementExpression (go.PointerType sync.Cond) "$v2")])))).

(* Add `n` threads that the barrier is waiting to call `Done()`.

   go: barrier.go:33:19 *)
Definition Barrier__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "n",
    exception_do (let: "b" := (GoAlloc (go.PointerType Barrier) "b") in
    let: "n" := (GoAlloc go.uint64 "n") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b"))) in
    let: "$a1" := (![go.uint64] "n") in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    return: #()).

(* Mark one thread as done.

   go: barrier.go:40:19 *)
Definition Barrier__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType Barrier) "b") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b"))) =⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"Done() called too many times"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := ((![go.uint64] (StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b")) <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b"))) =⟨go.uint64⟩ #(W64 0))
    then do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Barrier "cond"%go (![go.PointerType Barrier] "b")))) #())
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    return: #()).

(* Wait blocks until all threads pending with `Add()` have called `Done()`.

   go: barrier.go:53:19 *)
Definition Barrier__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType Barrier) "b") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    (for: (λ: <>, (![go.uint64] (StructFieldRef Barrier "numWaiting"%go (![go.PointerType Barrier] "b"))) >⟨go.uint64⟩ #(W64 0)); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Barrier "cond"%go (![go.PointerType Barrier] "b")))) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Barrier "mu"%go (![go.PointerType Barrier] "b")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.barrier :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.barrier (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module Barrier.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  numWaiting' : w64;
  mu' : loc;
  cond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Barrier.

Definition Barrier'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "numWaiting"%go go.uint64);
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond))
].
Program Definition Barrier'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Barrier'fds_unsealed).
Global Instance equals_unfold_Barrier {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Barrier'fds =→ Barrier'fds_unsealed.
Proof. rewrite /Barrier'fds seal_eq //. Qed.

Definition Barrierⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Barrier'fds).

Class Barrier_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Barrier_type_repr  :: go.TypeReprUnderlying Barrierⁱᵐᵖˡ Barrier.t;
  #[global] Barrier_underlying :: (Barrier) <u (Barrierⁱᵐᵖˡ);
  #[global] Barrier_get_numWaiting (x : Barrier.t) :: ⟦StructFieldGet (Barrierⁱᵐᵖˡ) "numWaiting", #x⟧ ⤳[under] #x.(Barrier.numWaiting');
  #[global] Barrier_set_numWaiting (x : Barrier.t) y :: ⟦StructFieldSet (Barrierⁱᵐᵖˡ) "numWaiting", (#x, #y)⟧ ⤳[under] #(x <|Barrier.numWaiting' := y|>);
  #[global] Barrier_get_mu (x : Barrier.t) :: ⟦StructFieldGet (Barrierⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Barrier.mu');
  #[global] Barrier_set_mu (x : Barrier.t) y :: ⟦StructFieldSet (Barrierⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Barrier.mu' := y|>);
  #[global] Barrier_get_cond (x : Barrier.t) :: ⟦StructFieldGet (Barrierⁱᵐᵖˡ) "cond", #x⟧ ⤳[under] #x.(Barrier.cond');
  #[global] Barrier_set_cond (x : Barrier.t) y :: ⟦StructFieldSet (Barrierⁱᵐᵖˡ) "cond", (#x, #y)⟧ ⤳[under] #(x <|Barrier.cond' := y|>);
  #[global] Barrier'ptr_Add_unfold :: MethodUnfold (go.PointerType (Barrier)) "Add" (Barrier__Addⁱᵐᵖˡ);
  #[global] Barrier'ptr_Done_unfold :: MethodUnfold (go.PointerType (Barrier)) "Done" (Barrier__Doneⁱᵐᵖˡ);
  #[global] Barrier'ptr_Wait_unfold :: MethodUnfold (go.PointerType (Barrier)) "Wait" (Barrier__Waitⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Barrier_instance :: Barrier_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
}.
End barrier.
