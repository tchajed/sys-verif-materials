(* autogenerated from sys_verif_code/functional *)
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition functional : go_string := "sys_verif_code/functional".

End pkg_id.
Export pkg_id.
Module functional.

Definition Add {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Add"%go.

Definition Max {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Max"%go.

Definition Midpoint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Midpoint"%go.

Definition Midpoint2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Midpoint2"%go.

Definition Arith {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Arith"%go.

Definition SumNrec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.SumNrec"%go.

Definition SumN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.SumN"%go.

Definition SumN2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.SumN2"%go.

Definition Fibonacci {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Fibonacci"%go.

Definition Factorial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.Factorial"%go.

Definition FastExp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/functional.FastExp"%go.

(* Add returns the sum of a and b

   go: functional.go:6:6 *)
Definition Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    return: ((![go.uint64] "a") +⟨go.uint64⟩ (![go.uint64] "b"))).

(* Max returns the max of a and b

   go: functional.go:11:6 *)
Definition Maxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "a") >⟨go.uint64⟩ (![go.uint64] "b"))
    then return: (![go.uint64] "a")
    else do:  #());;;
    return: (![go.uint64] "b")).

(* go: functional.go:18:6 *)
Definition Midpointⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y")) /⟨go.uint64⟩ #(W64 2))).

(* Midpoint2 calculates the midpoint in an overflow-proof way

   go: functional.go:23:6 *)
Definition Midpoint2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") ≤⟨go.uint64⟩ (![go.uint64] "y"))
    then return: ((![go.uint64] "x") +⟨go.uint64⟩ (((![go.uint64] "y") -⟨go.uint64⟩ (![go.uint64] "x")) /⟨go.uint64⟩ #(W64 2)))
    else return: ((![go.uint64] "y") +⟨go.uint64⟩ (((![go.uint64] "x") -⟨go.uint64⟩ (![go.uint64] "y")) /⟨go.uint64⟩ #(W64 2))))).

(* go: functional.go:31:6 *)
Definition Arithⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "a") +⟨go.uint64⟩ (![go.uint64] "b")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "sum") =⟨go.uint64⟩ #(W64 7))
    then return: (![go.uint64] "a")
    else do:  #());;;
    let: "mid" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "a") in
    let: "$a1" := (![go.uint64] "b") in
    (FuncResolve Midpoint2 [] #()) "$a0" "$a1") in
    do:  ("mid" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "mid")).

(* SumNrec adds up the numbers from 1 to n, recursively.

   go: functional.go:41:6 *)
Definition SumNrecⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") =⟨go.uint64⟩ #(W64 0))
    then return: (#(W64 0))
    else do:  #());;;
    return: ((![go.uint64] "n") +⟨go.uint64⟩ (let: "$a0" := ((![go.uint64] "n") -⟨go.uint64⟩ #(W64 1)) in
     (FuncResolve SumNrec [] #()) "$a0"))).

(* SumN adds up the numbers from 1 to n, with a loop.

   go: functional.go:49:6 *)
Definition SumNⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ (![go.uint64] "n"))
      then break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.uint64] "sum") in
      let: "$a1" := (![go.uint64] "i") in
      (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
      do:  ("sum" <-[go.uint64] "$r0");;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    return: (![go.uint64] "sum")).

(* SumN2 is a variation on SumN: it uses a different loop and signed integers

   go: functional.go:63:6 *)
Definition SumN2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.int "n") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "n")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![go.uint64] "sum") in
      let: "$a1" := (Convert go.int go.uint64 (![go.int] "i")) in
      (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

(* Fibonacci returns the nth Fibonacci number

   go: functional.go:72:6 *)
Definition Fibonacciⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") =⟨go.uint64⟩ #(W64 0))
    then return: (#(W64 0))
    else do:  #());;;
    let: "fib_prev" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("fib_prev" <-[go.uint64] "$r0");;;
    let: "fib_cur" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("fib_cur" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "fib_next" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((![go.uint64] "fib_cur") +⟨go.uint64⟩ (![go.uint64] "fib_prev")) in
      do:  ("fib_next" <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] "fib_cur") in
      do:  ("fib_prev" <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] "fib_next") in
      do:  ("fib_cur" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "fib_cur")).

(* Factorial returns n factorial

   go: functional.go:87:6 *)
Definition Factorialⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") =⟨go.uint64⟩ #(W64 0))
    then return: (#(W64 1))
    else do:  #());;;
    let: "fact" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("fact" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := ((![go.uint64] "fact") *⟨go.uint64⟩ ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))) in
      do:  ("fact" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "fact")).

(* FastExp returns b to the power of n0

   go: functional.go:101:6 *)
Definition FastExpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "n0",
    exception_do (let: "n0" := (GoAlloc go.uint64 "n0") in
    let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("a" <-[go.uint64] "$r0");;;
    let: "c" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "b") in
    do:  ("c" <-[go.uint64] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "n0") in
    do:  ("n" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "n") >⟨go.uint64⟩ #(W64 0)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool (((![go.uint64] "n") %⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 1))
      then
        let: "$r0" := ((![go.uint64] "a") *⟨go.uint64⟩ (![go.uint64] "c")) in
        do:  ("a" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "n") /⟨go.uint64⟩ #(W64 2)) in
        do:  ("n" <-[go.uint64] "$r0")
      else
        let: "$r0" := ((![go.uint64] "n") /⟨go.uint64⟩ #(W64 2)) in
        do:  ("n" <-[go.uint64] "$r0"));;;
      let: "$r0" := ((![go.uint64] "c") *⟨go.uint64⟩ (![go.uint64] "c")) in
      do:  ("c" <-[go.uint64] "$r0"));;;
    return: (![go.uint64] "a")).

#[global] Instance info' : PkgInfo pkg_id.functional :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.functional (λ: <>,
      exception_do (do:  (std.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Add_unfold :: FuncUnfold Add [] (Addⁱᵐᵖˡ);
  #[global] Max_unfold :: FuncUnfold Max [] (Maxⁱᵐᵖˡ);
  #[global] Midpoint_unfold :: FuncUnfold Midpoint [] (Midpointⁱᵐᵖˡ);
  #[global] Midpoint2_unfold :: FuncUnfold Midpoint2 [] (Midpoint2ⁱᵐᵖˡ);
  #[global] Arith_unfold :: FuncUnfold Arith [] (Arithⁱᵐᵖˡ);
  #[global] SumNrec_unfold :: FuncUnfold SumNrec [] (SumNrecⁱᵐᵖˡ);
  #[global] SumN_unfold :: FuncUnfold SumN [] (SumNⁱᵐᵖˡ);
  #[global] SumN2_unfold :: FuncUnfold SumN2 [] (SumN2ⁱᵐᵖˡ);
  #[global] Fibonacci_unfold :: FuncUnfold Fibonacci [] (Fibonacciⁱᵐᵖˡ);
  #[global] Factorial_unfold :: FuncUnfold Factorial [] (Factorialⁱᵐᵖˡ);
  #[global] FastExp_unfold :: FuncUnfold FastExp [] (FastExpⁱᵐᵖˡ);
  #[global] import_std_Assumption :: std.Assumptions;
}.
End functional.
