(* autogenerated from sys_verif_code/hashmap *)
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition hashmap : go_string := "sys_verif_code/hashmap".

End pkg_id.
Export pkg_id.
Module hashmap.

Definition atomicPtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/hashmap.atomicPtr"%go [].

Definition HashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/hashmap.HashMap"%go [].

Definition newAtomicPtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/hashmap.newAtomicPtr"%go.

Definition NewHashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/hashmap.NewHashMap"%go.

Definition mapClone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/hashmap.mapClone"%go.

(* go: hashmap.go:10:6 *)
Definition newAtomicPtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    return: (GoAlloc atomicPtr (let: "$v0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
     let: "$v1" := (![go.MapType go.uint64 go.uint64] "m") in
     CompositeLiteral atomicPtr (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v0"); KeyedElement (Some (KeyField "val"%go)) (ElementExpression (go.MapType go.uint64 go.uint64) "$v1")])))).

(* go: hashmap.go:14:21 *)
Definition atomicPtr__loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType atomicPtr) "a") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef atomicPtr "mu"%go (![go.PointerType atomicPtr] "a")))) #());;;
    let: "val" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := (![go.MapType go.uint64 go.uint64] (StructFieldRef atomicPtr "val"%go (![go.PointerType atomicPtr] "a"))) in
    do:  ("val" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef atomicPtr "mu"%go (![go.PointerType atomicPtr] "a")))) #());;;
    return: (![go.MapType go.uint64 go.uint64] "val")).

(* go: hashmap.go:21:21 *)
Definition atomicPtr__storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "m",
    exception_do (let: "a" := (GoAlloc (go.PointerType atomicPtr) "a") in
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef atomicPtr "mu"%go (![go.PointerType atomicPtr] "a")))) #());;;
    let: "$r0" := (![go.MapType go.uint64 go.uint64] "m") in
    do:  ((StructFieldRef atomicPtr "val"%go (![go.PointerType atomicPtr] "a")) <-[go.MapType go.uint64 go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef atomicPtr "mu"%go (![go.PointerType atomicPtr] "a")))) #());;;
    return: #()).

(* go: hashmap.go:42:6 *)
Definition NewHashMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    return: (GoAlloc HashMap (let: "$v0" := (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
     (FuncResolve newAtomicPtr [] #()) "$a0") in
     let: "$v1" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
     CompositeLiteral HashMap (LiteralValue [KeyedElement (Some (KeyField "clean"%go)) (ElementExpression (go.PointerType atomicPtr) "$v0"); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v1")])))).

(* go: hashmap.go:47:19 *)
Definition HashMap__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" "key",
    exception_do (let: "h" := (GoAlloc (go.PointerType HashMap) "h") in
    let: "key" := (GoAlloc go.uint64 "key") in
    let: "clean" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType atomicPtr) "load"%go (![go.PointerType atomicPtr] (StructFieldRef HashMap "clean"%go (![go.PointerType HashMap] "h")))) #()) in
    do:  ("clean" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "value" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.uint64 (![go.MapType go.uint64 go.uint64] "clean") (![go.uint64] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("value" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    return: (![go.uint64] "value", ![go.bool] "ok")).

(* Clone the input map by copying all values.

   go: hashmap.go:54:6 *)
Definition mapCloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "clone" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.MapType go.uint64 go.uint64] #()) ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0") +⟨go.int⟩ #(W64 1))) in
    do:  ("clone" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := (![go.uint64] "v") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "clone") (![go.uint64] "k") "$r0")));;;
    return: (![go.MapType go.uint64 go.uint64] "clone")).

(* Assuming mu is held, return an owned copy of the current clean map.

   go: hashmap.go:63:19 *)
Definition HashMap__dirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" <>,
    exception_do (let: "h" := (GoAlloc (go.PointerType HashMap) "h") in
    let: "clean" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType atomicPtr) "load"%go (![go.PointerType atomicPtr] (StructFieldRef HashMap "clean"%go (![go.PointerType HashMap] "h")))) #()) in
    do:  ("clean" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    return: (let: "$a0" := (![go.MapType go.uint64 go.uint64] "clean") in
     (FuncResolve mapClone [] #()) "$a0")).

(* go: hashmap.go:68:19 *)
Definition HashMap__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" "key" "value",
    exception_do (let: "h" := (GoAlloc (go.PointerType HashMap) "h") in
    let: "value" := (GoAlloc go.uint64 "value") in
    let: "key" := (GoAlloc go.uint64 "key") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef HashMap "mu"%go (![go.PointerType HashMap] "h")))) #());;;
    let: "dirty" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType HashMap) "dirty"%go (![go.PointerType HashMap] "h")) #()) in
    do:  ("dirty" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "value") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "dirty") (![go.uint64] "key") "$r0");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 go.uint64] "dirty") in
    (MethodResolve (go.PointerType atomicPtr) "store"%go (![go.PointerType atomicPtr] (StructFieldRef HashMap "clean"%go (![go.PointerType HashMap] "h")))) "$a0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef HashMap "mu"%go (![go.PointerType HashMap] "h")))) #());;;
    return: #()).

(* go: hashmap.go:76:19 *)
Definition HashMap__Deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" "key",
    exception_do (let: "h" := (GoAlloc (go.PointerType HashMap) "h") in
    let: "key" := (GoAlloc go.uint64 "key") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef HashMap "mu"%go (![go.PointerType HashMap] "h")))) #());;;
    let: "dirty" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType HashMap) "dirty"%go (![go.PointerType HashMap] "h")) #()) in
    do:  ("dirty" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 go.uint64] "dirty") in
    let: "$a1" := (![go.uint64] "key") in
    (FuncResolve go.delete [go.MapType go.uint64 go.uint64] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 go.uint64] "dirty") in
    (MethodResolve (go.PointerType atomicPtr) "store"%go (![go.PointerType atomicPtr] (StructFieldRef HashMap "clean"%go (![go.PointerType HashMap] "h")))) "$a0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef HashMap "mu"%go (![go.PointerType HashMap] "h")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.hashmap :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.hashmap (λ: <>,
      exception_do (do:  (sync.initialize' #()))
      ).

Module atomicPtr.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  val' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End atomicPtr.

Definition atomicPtr'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "val"%go (go.MapType go.uint64 go.uint64))
].
Program Definition atomicPtr'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (atomicPtr'fds_unsealed).
Global Instance equals_unfold_atomicPtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : atomicPtr'fds =→ atomicPtr'fds_unsealed.
Proof. rewrite /atomicPtr'fds seal_eq //. Qed.

Definition atomicPtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (atomicPtr'fds).

Class atomicPtr_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] atomicPtr_type_repr  :: go.TypeReprUnderlying atomicPtrⁱᵐᵖˡ atomicPtr.t;
  #[global] atomicPtr_underlying :: (atomicPtr) <u (atomicPtrⁱᵐᵖˡ);
  #[global] atomicPtr_get_mu (x : atomicPtr.t) :: ⟦StructFieldGet (atomicPtrⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(atomicPtr.mu');
  #[global] atomicPtr_set_mu (x : atomicPtr.t) y :: ⟦StructFieldSet (atomicPtrⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|atomicPtr.mu' := y|>);
  #[global] atomicPtr_get_val (x : atomicPtr.t) :: ⟦StructFieldGet (atomicPtrⁱᵐᵖˡ) "val", #x⟧ ⤳[under] #x.(atomicPtr.val');
  #[global] atomicPtr_set_val (x : atomicPtr.t) y :: ⟦StructFieldSet (atomicPtrⁱᵐᵖˡ) "val", (#x, #y)⟧ ⤳[under] #(x <|atomicPtr.val' := y|>);
  #[global] atomicPtr'ptr_load_unfold :: MethodUnfold (go.PointerType (atomicPtr)) "load" (atomicPtr__loadⁱᵐᵖˡ);
  #[global] atomicPtr'ptr_store_unfold :: MethodUnfold (go.PointerType (atomicPtr)) "store" (atomicPtr__storeⁱᵐᵖˡ);
}.

Module HashMap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  clean' : loc;
  mu' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End HashMap.

Definition HashMap'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "clean"%go (go.PointerType atomicPtr));
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex))
].
Program Definition HashMap'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (HashMap'fds_unsealed).
Global Instance equals_unfold_HashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : HashMap'fds =→ HashMap'fds_unsealed.
Proof. rewrite /HashMap'fds seal_eq //. Qed.

Definition HashMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (HashMap'fds).

Class HashMap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HashMap_type_repr  :: go.TypeReprUnderlying HashMapⁱᵐᵖˡ HashMap.t;
  #[global] HashMap_underlying :: (HashMap) <u (HashMapⁱᵐᵖˡ);
  #[global] HashMap_get_clean (x : HashMap.t) :: ⟦StructFieldGet (HashMapⁱᵐᵖˡ) "clean", #x⟧ ⤳[under] #x.(HashMap.clean');
  #[global] HashMap_set_clean (x : HashMap.t) y :: ⟦StructFieldSet (HashMapⁱᵐᵖˡ) "clean", (#x, #y)⟧ ⤳[under] #(x <|HashMap.clean' := y|>);
  #[global] HashMap_get_mu (x : HashMap.t) :: ⟦StructFieldGet (HashMapⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(HashMap.mu');
  #[global] HashMap_set_mu (x : HashMap.t) y :: ⟦StructFieldSet (HashMapⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|HashMap.mu' := y|>);
  #[global] HashMap'ptr_Delete_unfold :: MethodUnfold (go.PointerType (HashMap)) "Delete" (HashMap__Deleteⁱᵐᵖˡ);
  #[global] HashMap'ptr_Load_unfold :: MethodUnfold (go.PointerType (HashMap)) "Load" (HashMap__Loadⁱᵐᵖˡ);
  #[global] HashMap'ptr_Store_unfold :: MethodUnfold (go.PointerType (HashMap)) "Store" (HashMap__Storeⁱᵐᵖˡ);
  #[global] HashMap'ptr_dirty_unfold :: MethodUnfold (go.PointerType (HashMap)) "dirty" (HashMap__dirtyⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] atomicPtr_instance :: atomicPtr_Assumptions;
  #[global] HashMap_instance :: HashMap_Assumptions;
  #[global] newAtomicPtr_unfold :: FuncUnfold newAtomicPtr [] (newAtomicPtrⁱᵐᵖˡ);
  #[global] NewHashMap_unfold :: FuncUnfold NewHashMap [] (NewHashMapⁱᵐᵖˡ);
  #[global] mapClone_unfold :: FuncUnfold mapClone [] (mapCloneⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End hashmap.
