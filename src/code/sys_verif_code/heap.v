(* autogenerated from sys_verif_code/heap *)
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition heap : go_string := "sys_verif_code/heap".

End pkg_id.
Export pkg_id.
Module heap.

Definition S1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.S1"%go [].

Definition Stack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.Stack"%go [].

Definition Queue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.Queue"%go [].

Definition SearchTree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.SearchTree"%go [].

Definition Person {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.Person"%go [].

Definition Rect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap.Rect"%go [].

Definition BinarySearch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.BinarySearch"%go.

Definition ExampleA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleA"%go.

Definition ExampleB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleB"%go.

Definition ExampleC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleC"%go.

Definition ExampleD {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleD"%go.

Definition ExampleE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleE"%go.

Definition collatzF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.collatzF"%go.

Definition collatzIter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.collatzIter"%go.

Definition ExampleG {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExampleG"%go.

Definition Swap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.Swap"%go.

Definition IgnoreOne {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.IgnoreOne"%go.

Definition UseIgnoreOneOwnership {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.UseIgnoreOneOwnership"%go.

Definition CopySlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.CopySlice"%go.

Definition StackEscape {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.StackEscape"%go.

Definition SliceSwap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.SliceSwap"%go.

Definition FindMajority {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.FindMajority"%go.

Definition NewStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.NewStack"%go.

Definition NewQueue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.NewQueue"%go.

Definition NewSearchTree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.NewSearchTree"%go.

Definition singletonTree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.singletonTree"%go.

Definition ExamplePerson {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExamplePerson"%go.

Definition ExamplePersonRef {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.ExamplePersonRef"%go.

Definition IsSquare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.IsSquare"%go.

Definition Rotate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap.Rotate"%go.

(* BinarySearch looks for needle in the sorted list s. It returns (index, found)
   where if found = false, needle is not present in s, and if found = true, s[index]
   == needle.

   If needle appears multiple times in s, no guarantees are made about which of
   those indices is returned.

   go: binary_search.go:9:6 *)
Definition BinarySearchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "needle",
    exception_do (let: "needle" := (GoAlloc go.uint64 "needle") in
    let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "s") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") in
    do:  ("j" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
      let: "mid" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "i") +⟨go.int⟩ (((![go.int] "j") -⟨go.int⟩ (![go.int] "i")) /⟨go.int⟩ #(W64 2))) in
      do:  ("mid" <-[go.int] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", ![go.int] "mid"))) <⟨go.uint64⟩ (![go.uint64] "needle"))
      then
        let: "$r0" := ((![go.int] "mid") +⟨go.int⟩ #(W64 1)) in
        do:  ("i" <-[go.int] "$r0")
      else
        let: "$r0" := (![go.int] "mid") in
        do:  ("j" <-[go.int] "$r0")));;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType go.uint64] "s") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))
    then return: (![go.int] "i", (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", ![go.int] "i"))) =⟨go.uint64⟩ (![go.uint64] "needle"))
    else do:  #());;;
    return: (![go.int] "i", #false)).

(* go: exercises.go:5:6 *)
Definition ExampleAⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc (go.PointerType go.uint64) "y") in
    let: "x" := (GoAlloc (go.PointerType go.bool) "x") in
    (if: ![go.bool] (![go.PointerType go.bool] "x")
    then
      let: "$r0" := (![go.uint64] "z") in
      do:  ((![go.PointerType go.uint64] "y") <-[go.uint64] "$r0")
    else
      let: "$r0" := #(W64 0) in
      do:  ((![go.PointerType go.uint64] "y") <-[go.uint64] "$r0"));;;
    return: #()).

(* go: exercises.go:13:6 *)
Definition ExampleBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc (go.PointerType go.uint64) "y") in
    let: "x" := (GoAlloc (go.PointerType go.bool) "x") in
    (if: ![go.bool] (![go.PointerType go.bool] "x")
    then
      do:  (let: "$a0" := ((![go.uint64] "z") =⟨go.uint64⟩ #(W64 0)) in
      (FuncResolve std.Assert [] #()) "$a0");;;
      let: "$r0" := (![go.uint64] "z") in
      do:  ((![go.PointerType go.uint64] "y") <-[go.uint64] "$r0")
    else
      let: "$r0" := #(W64 0) in
      do:  ((![go.PointerType go.uint64] "y") <-[go.uint64] "$r0"));;;
    return: #()).

(* go: exercises.go:27:6 *)
Definition ExampleCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType S1) "x") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef S1 "a"%go (![go.PointerType S1] "x"))) =⟨go.uint64⟩ #(W64 0))
    then return: (#"false"%go)
    else do:  #());;;
    return: (#"true"%go)).

(* go: exercises.go:34:6 *)
Definition ExampleDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType S1) "x") in
    do:  (let: "$a0" := ((![go.uint64] (StructFieldRef S1 "a"%go (![go.PointerType S1] "x"))) =⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef S1 "b"%go (![go.PointerType S1] "x"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef S1 "b"%go (![go.PointerType S1] "x")), #(W64 0))))).

(* go: exercises.go:39:6 *)
Definition ExampleEⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc (go.PointerType S1) "y") in
    let: "x" := (GoAlloc S1 "x") in
    let: "$r0" := (![go.uint64] (StructFieldRef S1 "a"%go "x")) in
    do:  ((StructFieldRef S1 "a"%go (![go.PointerType S1] "y")) <-[go.uint64] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    do:  ((StructFieldRef S1 "b"%go (![go.PointerType S1] "y")) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: exercises.go:44:6 *)
Definition collatzFⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "x") %⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 0))
    then return: ((![go.uint64] "x") /⟨go.uint64⟩ #(W64 2))
    else return: ((#(W64 3) *⟨go.uint64⟩ (![go.uint64] "x")) +⟨go.uint64⟩ #(W64 1)))).

(* go: exercises.go:52:6 *)
Definition collatzIterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    let: "x" := (GoAlloc go.uint64 "x") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") =⟨go.uint64⟩ #(W64 0))
    then return: (![go.uint64] "x")
    else
      return: (let: "$a0" := (let: "$a0" := (![go.uint64] "x") in
       (FuncResolve collatzF [] #()) "$a0") in
       let: "$a1" := ((![go.uint64] "n") -⟨go.uint64⟩ #(W64 1)) in
       (FuncResolve collatzIter [] #()) "$a0" "$a1"))).

(* go: exercises.go:60:6 *)
Definition ExampleGⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := #(W64 12) in
     let: "$a1" := #(W64 9) in
     (FuncResolve collatzIter [] #()) "$a0" "$a1")).

(* go: heap.go:5:6 *)
Definition Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc (go.PointerType go.int) "y") in
    let: "x" := (GoAlloc (go.PointerType go.int) "x") in
    let: "old_y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] (![go.PointerType go.int] "y")) in
    do:  ("old_y" <-[go.int] "$r0");;;
    let: "$r0" := (![go.int] (![go.PointerType go.int] "x")) in
    do:  ((![go.PointerType go.int] "y") <-[go.int] "$r0");;;
    let: "$r0" := (![go.int] "old_y") in
    do:  ((![go.PointerType go.int] "x") <-[go.int] "$r0");;;
    return: #()).

(* IgnoreOne has a specification that shows it does not need ownership of
   its second argument.

   go: heap.go:13:6 *)
Definition IgnoreOneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc (go.PointerType go.int) "y") in
    let: "x" := (GoAlloc (go.PointerType go.int) "x") in
    do:  (let: "$a0" := ((![go.int] (![go.PointerType go.int] "x")) =⟨go.int⟩ #(W64 0)) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := #(W64 42) in
    do:  ((![go.PointerType go.int] "x") <-[go.int] "$r0");;;
    return: #()).

(* UseIgnoreOneOwnership uses IgnoreOneLocF and can be verified using its
   specification.

   go: heap.go:20:6 *)
Definition UseIgnoreOneOwnershipⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 42) in
    do:  ("y" <-[go.int] "$r0");;;
    do:  (let: "$a0" := "x" in
    let: "$a1" := "y" in
    (FuncResolve IgnoreOne [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![go.int] "x") =⟨go.int⟩ (![go.int] "y")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: #()).

(* CopySlice copies from src to dst

   dst must be at least as long as src

   go: heap.go:30:6 *)
Definition CopySliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "dst" "src",
    exception_do (let: "src" := (GoAlloc (go.SliceType go.byte) "src") in
    let: "dst" := (GoAlloc (go.SliceType go.byte) "dst") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType go.byte] "dst") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "src", ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "dst", ![go.int] "i")) <-[go.byte] "$r0")));;;
    return: #()).

(* StackEscape shows a local variable being promoted to the heap.

   This illustrates both how Go works and ownership principles.

   go: heap.go:39:6 *)
Definition StackEscapeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 42) in
    do:  ("x" <-[go.int] "$r0");;;
    return: ("x")).

(* go: heap.go:44:6 *)
Definition SliceSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "i" "j",
    exception_do (let: "j" := (GoAlloc go.int "j") in
    let: "i" := (GoAlloc go.int "i") in
    let: "s" := (GoAlloc (go.SliceType go.int) "s") in
    let: "$r0" := (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "j"))) in
    let: "$r1" := (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i"))) in
    do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i")) <-[go.int] "$r0");;;
    do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "j")) <-[go.int] "$r1");;;
    return: #()).

(* FindMajority finds an `x` that appears in the slice `a` more than half the
   time.

   That is, if there is some x that appears in a strictly more than `len(a)/2`
   times, then `FindMajority` will return it.

   This implementation of the algorithm comes from _Program Proofs_ by K. Rustan
   M. Leino in chapter 13.7.

   go: majority_vote.go:11:6 *)
Definition FindMajorityⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc (go.SliceType go.uint32) "a") in
    let: "k" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (![go.uint32] (IndexRef (go.SliceType go.uint32) (![go.SliceType go.uint32] "a", #(W64 0)))) in
    do:  ("k" <-[go.uint32] "$r0");;;
    let: "lo" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("lo" <-[go.uint64] "$r0");;;
    let: "hi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("hi" <-[go.uint64] "$r0");;;
    let: "c" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("c" <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint32] "a") in
    (FuncResolve go.len [go.SliceType go.uint32] #()) "$a0")) in
    do:  ("l" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "hi") <⟨go.uint64⟩ (![go.uint64] "l")); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint32] (IndexRef (go.SliceType go.uint32) (![go.SliceType go.uint32] "a", Convert go.uint64 go.int (![go.uint64] "hi")))) =⟨go.uint32⟩ (![go.uint32] "k"))
      then
        let: "$r0" := ((![go.uint64] "hi") +⟨go.uint64⟩ #(W64 1)) in
        let: "$r1" := ((![go.uint64] "c") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("hi" <-[go.uint64] "$r0");;;
        do:  ("c" <-[go.uint64] "$r1")
      else
        (if: Convert go.untyped_bool go.bool ((((![go.uint64] "hi") +⟨go.uint64⟩ #(W64 1)) -⟨go.uint64⟩ (![go.uint64] "lo")) <⟨go.uint64⟩ (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "c")))
        then do:  ("hi" <-[go.uint64] ((![go.uint64] "hi") +⟨go.uint64⟩ #(W64 1)))
        else
          do:  ("hi" <-[go.uint64] ((![go.uint64] "hi") +⟨go.uint64⟩ #(W64 1)));;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "hi") =⟨go.uint64⟩ (![go.uint64] "l"))
          then break: #()
          else do:  #());;;
          let: "$r0" := (![go.uint32] (IndexRef (go.SliceType go.uint32) (![go.SliceType go.uint32] "a", Convert go.uint64 go.int (![go.uint64] "hi")))) in
          let: "$r1" := (![go.uint64] "hi") in
          let: "$r2" := ((![go.uint64] "hi") +⟨go.uint64⟩ #(W64 1)) in
          let: "$r3" := #(W64 1) in
          do:  ("k" <-[go.uint32] "$r0");;;
          do:  ("lo" <-[go.uint64] "$r1");;;
          do:  ("hi" <-[go.uint64] "$r2");;;
          do:  ("c" <-[go.uint64] "$r3"))));;;
    return: (![go.uint32] "k")).

(* go: queue.go:7:6 *)
Definition NewStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc Stack (let: "$v0" := (CompositeLiteral (go.SliceType go.uint64) (LiteralValue [])) in
     CompositeLiteral Stack (LiteralValue [KeyedElement (Some (KeyField "elements"%go)) (ElementExpression (go.SliceType go.uint64) "$v0")])))).

(* go: queue.go:13:17 *)
Definition Stack__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "x",
    exception_do (let: "s" := (GoAlloc (go.PointerType Stack) "s") in
    let: "x" := (GoAlloc go.uint64 "x") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![go.uint64] "x") in
    CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s")) <-[go.SliceType go.uint64] "$r0");;;
    return: #()).

(* Pop returns the most recently pushed element. The boolean indicates success,
   which is false if the stack was empty.

   go: queue.go:19:17 *)
Definition Stack__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Stack) "s") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s"))) in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s")), (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s"))) in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") -⟨go.int⟩ #(W64 1)))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s"))) in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s"))) in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") -⟨go.int⟩ #(W64 1))) in
    do:  ((StructFieldRef Stack "elements"%go (![go.PointerType Stack] "s")) <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.uint64] "x", #true)).

(* go: queue.go:33:6 *)
Definition NewQueueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$v0" := ((FuncResolve NewStack [] #()) #()) in
     let: "$v1" := ((FuncResolve NewStack [] #()) #()) in
     CompositeLiteral Queue (LiteralValue [KeyedElement (Some (KeyField "back"%go)) (ElementExpression (go.PointerType Stack) "$v0"); KeyedElement (Some (KeyField "front"%go)) (ElementExpression (go.PointerType Stack) "$v1")]))).

(* go: queue.go:40:16 *)
Definition Queue__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "q" "x",
    exception_do (let: "q" := (GoAlloc Queue "q") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := (![go.uint64] "x") in
    (MethodResolve (go.PointerType Stack) "Push"%go (![go.PointerType Stack] (StructFieldRef Queue "back"%go "q"))) "$a0");;;
    return: #()).

(* go: queue.go:44:16 *)
Definition Queue__emptyBackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "q" <>,
    exception_do (let: "q" := (GoAlloc Queue "q") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType Stack) "Pop"%go (![go.PointerType Stack] (StructFieldRef Queue "back"%go "q"))) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("x" <-[go.uint64] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := (![go.uint64] "x") in
        (MethodResolve (go.PointerType Stack) "Push"%go (![go.PointerType Stack] (StructFieldRef Queue "front"%go "q"))) "$a0")
      else break: #()));;;
    return: #()).

(* go: queue.go:55:16 *)
Definition Queue__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "q" <>,
    exception_do (let: "q" := (GoAlloc Queue "q") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType Stack) "Pop"%go (![go.PointerType Stack] (StructFieldRef Queue "front"%go "q"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "x", #true)
    else do:  #());;;
    do:  ((MethodResolve Queue "emptyBack"%go (![Queue] "q")) #());;;
    let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType Stack) "Pop"%go (![go.PointerType Stack] (StructFieldRef Queue "front"%go "q"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("ok2" <-[go.bool] "$r1");;;
    return: (![go.uint64] "x", ![go.bool] "ok2")).

(* go: search_tree.go:9:6 *)
Definition NewSearchTreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Convert go.untyped_nil (go.PointerType SearchTree) UntypedNil)).

(* go: search_tree.go:13:6 *)
Definition singletonTreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key",
    exception_do (let: "key" := (GoAlloc go.uint64 "key") in
    return: (GoAlloc SearchTree (let: "$v0" := (![go.uint64] "key") in
     let: "$v1" := UntypedNil in
     let: "$v2" := UntypedNil in
     CompositeLiteral SearchTree (LiteralValue [KeyedElement (Some (KeyField "key"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "left"%go)) (ElementExpression go.untyped_nil "$v1"); KeyedElement (Some (KeyField "right"%go)) (ElementExpression go.untyped_nil "$v2")])))).

(* go: search_tree.go:17:22 *)
Definition SearchTree__Insertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" "key",
    exception_do (let: "t" := (GoAlloc (go.PointerType SearchTree) "t") in
    let: "key" := (GoAlloc go.uint64 "key") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SearchTree] "t") =⟨go.PointerType SearchTree⟩ (Convert go.untyped_nil (go.PointerType SearchTree) UntypedNil))
    then
      return: (let: "$a0" := (![go.uint64] "key") in
       (FuncResolve singletonTree [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "key") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef SearchTree "key"%go (![go.PointerType SearchTree] "t"))))
    then
      let: "$r0" := (let: "$a0" := (![go.uint64] "key") in
      (MethodResolve (go.PointerType SearchTree) "Insert"%go (![go.PointerType SearchTree] (StructFieldRef SearchTree "left"%go (![go.PointerType SearchTree] "t")))) "$a0") in
      do:  ((StructFieldRef SearchTree "left"%go (![go.PointerType SearchTree] "t")) <-[go.PointerType SearchTree] "$r0")
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef SearchTree "key"%go (![go.PointerType SearchTree] "t"))) <⟨go.uint64⟩ (![go.uint64] "key"))
      then
        let: "$r0" := (let: "$a0" := (![go.uint64] "key") in
        (MethodResolve (go.PointerType SearchTree) "Insert"%go (![go.PointerType SearchTree] (StructFieldRef SearchTree "right"%go (![go.PointerType SearchTree] "t")))) "$a0") in
        do:  ((StructFieldRef SearchTree "right"%go (![go.PointerType SearchTree] "t")) <-[go.PointerType SearchTree] "$r0")
      else do:  #()));;;
    return: (![go.PointerType SearchTree] "t")).

(* go: search_tree.go:31:22 *)
Definition SearchTree__Containsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" "key",
    exception_do (let: "t" := (GoAlloc (go.PointerType SearchTree) "t") in
    let: "key" := (GoAlloc go.uint64 "key") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SearchTree] "t") =⟨go.PointerType SearchTree⟩ (Convert go.untyped_nil (go.PointerType SearchTree) UntypedNil))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "key") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef SearchTree "key"%go (![go.PointerType SearchTree] "t"))))
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "key") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef SearchTree "key"%go (![go.PointerType SearchTree] "t"))))
    then
      return: (let: "$a0" := (![go.uint64] "key") in
       (MethodResolve (go.PointerType SearchTree) "Contains"%go (![go.PointerType SearchTree] (StructFieldRef SearchTree "left"%go (![go.PointerType SearchTree] "t")))) "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![go.uint64] "key") in
     (MethodResolve (go.PointerType SearchTree) "Contains"%go (![go.PointerType SearchTree] (StructFieldRef SearchTree "right"%go (![go.PointerType SearchTree] "t")))) "$a0")).

(* go: struct.go:9:17 *)
Definition Person__Nameⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc Person "p") in
    return: (((![go.string] (StructFieldRef Person "FirstName"%go "p")) +⟨go.string⟩ #" "%go) +⟨go.string⟩ (![go.string] (StructFieldRef Person "LastName"%go "p")))).

(* go: struct.go:13:18 *)
Definition Person__Olderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" "delta",
    exception_do (let: "p" := (GoAlloc (go.PointerType Person) "p") in
    let: "delta" := (GoAlloc go.uint64 "delta") in
    do:  ((StructFieldRef Person "Age"%go (![go.PointerType Person] "p")) <-[go.uint64] ((![go.uint64] (StructFieldRef Person "Age"%go (![go.PointerType Person] "p"))) +⟨go.uint64⟩ (![go.uint64] "delta")));;;
    return: #()).

(* go: struct.go:17:18 *)
Definition Person__GetAgeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType Person) "p") in
    return: (StructFieldRef Person "Age"%go (![go.PointerType Person] "p"))).

(* go: struct.go:21:6 *)
Definition ExamplePersonⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$v0" := #"Ada"%go in
     let: "$v1" := #"Lovelace"%go in
     let: "$v2" := #(W64 25) in
     CompositeLiteral Person (LiteralValue [KeyedElement (Some (KeyField "FirstName"%go)) (ElementExpression go.string "$v0"); KeyedElement (Some (KeyField "LastName"%go)) (ElementExpression go.string "$v1"); KeyedElement (Some (KeyField "Age"%go)) (ElementExpression go.uint64 "$v2")]))).

(* go: struct.go:29:6 *)
Definition ExamplePersonRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc Person (let: "$v0" := #"Ada"%go in
     let: "$v1" := #"Lovelace"%go in
     let: "$v2" := #(W64 25) in
     CompositeLiteral Person (LiteralValue [KeyedElement (Some (KeyField "FirstName"%go)) (ElementExpression go.string "$v0"); KeyedElement (Some (KeyField "LastName"%go)) (ElementExpression go.string "$v1"); KeyedElement (Some (KeyField "Age"%go)) (ElementExpression go.uint64 "$v2")])))).

(* go: struct.go:37:17 *)
Definition Person__BuggySetAgeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc Person "p") in
    do:  ((StructFieldRef Person "Age"%go "p") <-[go.uint64] ((![go.uint64] (StructFieldRef Person "Age"%go "p")) +⟨go.uint64⟩ #(W64 1)));;;
    return: #()).

(* go: struct.go:46:16 *)
Definition Rect__Areaⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType Rect) "r") in
    return: ((![go.uint64] (StructFieldRef Rect "Width"%go (![go.PointerType Rect] "r"))) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef Rect "Height"%go (![go.PointerType Rect] "r"))))).

(* go: struct.go:50:6 *)
Definition IsSquareⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc Rect "r") in
    return: ((![go.uint64] (StructFieldRef Rect "Width"%go "r")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef Rect "Height"%go "r")))).

(* go: struct.go:54:16 *)
Definition Rect__MakeSquareⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType Rect) "r") in
    let: "$r0" := (![go.uint64] (StructFieldRef Rect "Width"%go (![go.PointerType Rect] "r"))) in
    do:  ((StructFieldRef Rect "Height"%go (![go.PointerType Rect] "r")) <-[go.uint64] "$r0");;;
    return: #()).

(* go: struct.go:58:6 *)
Definition Rotateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc (go.PointerType Rect) "r") in
    let: "$r0" := (![go.uint64] (StructFieldRef Rect "Height"%go (![go.PointerType Rect] "r"))) in
    let: "$r1" := (![go.uint64] (StructFieldRef Rect "Width"%go (![go.PointerType Rect] "r"))) in
    do:  ((StructFieldRef Rect "Width"%go (![go.PointerType Rect] "r")) <-[go.uint64] "$r0");;;
    do:  ((StructFieldRef Rect "Height"%go (![go.PointerType Rect] "r")) <-[go.uint64] "$r1");;;
    return: (![go.PointerType Rect] "r")).

#[global] Instance info' : PkgInfo pkg_id.heap :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.heap (λ: <>,
      exception_do (do:  (std.initialize' #()))
      ).

Module S1.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End S1.

Definition S1'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go (go.SliceType go.byte))
].
Program Definition S1'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (S1'fds_unsealed).
Global Instance equals_unfold_S1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : S1'fds =→ S1'fds_unsealed.
Proof. rewrite /S1'fds seal_eq //. Qed.

Definition S1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (S1'fds).

Class S1_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S1_type_repr  :: go.TypeReprUnderlying S1ⁱᵐᵖˡ S1.t;
  #[global] S1_underlying :: (S1) <u (S1ⁱᵐᵖˡ);
  #[global] S1_get_a (x : S1.t) :: ⟦StructFieldGet (S1ⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(S1.a');
  #[global] S1_set_a (x : S1.t) y :: ⟦StructFieldSet (S1ⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|S1.a' := y|>);
  #[global] S1_get_b (x : S1.t) :: ⟦StructFieldGet (S1ⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(S1.b');
  #[global] S1_set_b (x : S1.t) y :: ⟦StructFieldSet (S1ⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|S1.b' := y|>);
}.

Module Stack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  elements' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Stack.

Definition Stack'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "elements"%go (go.SliceType go.uint64))
].
Program Definition Stack'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Stack'fds_unsealed).
Global Instance equals_unfold_Stack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Stack'fds =→ Stack'fds_unsealed.
Proof. rewrite /Stack'fds seal_eq //. Qed.

Definition Stackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Stack'fds).

Class Stack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Stack_type_repr  :: go.TypeReprUnderlying Stackⁱᵐᵖˡ Stack.t;
  #[global] Stack_underlying :: (Stack) <u (Stackⁱᵐᵖˡ);
  #[global] Stack_get_elements (x : Stack.t) :: ⟦StructFieldGet (Stackⁱᵐᵖˡ) "elements", #x⟧ ⤳[under] #x.(Stack.elements');
  #[global] Stack_set_elements (x : Stack.t) y :: ⟦StructFieldSet (Stackⁱᵐᵖˡ) "elements", (#x, #y)⟧ ⤳[under] #(x <|Stack.elements' := y|>);
  #[global] Stack'ptr_Pop_unfold :: MethodUnfold (go.PointerType (Stack)) "Pop" (Stack__Popⁱᵐᵖˡ);
  #[global] Stack'ptr_Push_unfold :: MethodUnfold (go.PointerType (Stack)) "Push" (Stack__Pushⁱᵐᵖˡ);
}.

Module Queue.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  back' : loc;
  front' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Queue.

Definition Queue'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "back"%go (go.PointerType Stack));
  (go.FieldDecl "front"%go (go.PointerType Stack))
].
Program Definition Queue'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Queue'fds_unsealed).
Global Instance equals_unfold_Queue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Queue'fds =→ Queue'fds_unsealed.
Proof. rewrite /Queue'fds seal_eq //. Qed.

Definition Queueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Queue'fds).

Class Queue_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Queue_type_repr  :: go.TypeReprUnderlying Queueⁱᵐᵖˡ Queue.t;
  #[global] Queue_underlying :: (Queue) <u (Queueⁱᵐᵖˡ);
  #[global] Queue_get_back (x : Queue.t) :: ⟦StructFieldGet (Queueⁱᵐᵖˡ) "back", #x⟧ ⤳[under] #x.(Queue.back');
  #[global] Queue_set_back (x : Queue.t) y :: ⟦StructFieldSet (Queueⁱᵐᵖˡ) "back", (#x, #y)⟧ ⤳[under] #(x <|Queue.back' := y|>);
  #[global] Queue_get_front (x : Queue.t) :: ⟦StructFieldGet (Queueⁱᵐᵖˡ) "front", #x⟧ ⤳[under] #x.(Queue.front');
  #[global] Queue_set_front (x : Queue.t) y :: ⟦StructFieldSet (Queueⁱᵐᵖˡ) "front", (#x, #y)⟧ ⤳[under] #(x <|Queue.front' := y|>);
  #[global] Queue_Pop_unfold :: MethodUnfold (Queue) "Pop" (Queue__Popⁱᵐᵖˡ);
  #[global] Queue_Push_unfold :: MethodUnfold (Queue) "Push" (Queue__Pushⁱᵐᵖˡ);
  #[global] Queue_emptyBack_unfold :: MethodUnfold (Queue) "emptyBack" (Queue__emptyBackⁱᵐᵖˡ);
  #[global] Queue'ptr_Pop_unfold :: MethodUnfold (go.PointerType (Queue)) "Pop" (λ: "$r", MethodResolve (Queue) "Pop" (![(Queue)] "$r"));
  #[global] Queue'ptr_Push_unfold :: MethodUnfold (go.PointerType (Queue)) "Push" (λ: "$r", MethodResolve (Queue) "Push" (![(Queue)] "$r"));
  #[global] Queue'ptr_emptyBack_unfold :: MethodUnfold (go.PointerType (Queue)) "emptyBack" (λ: "$r", MethodResolve (Queue) "emptyBack" (![(Queue)] "$r"));
}.

Module SearchTree.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  key' : w64;
  left' : loc;
  right' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SearchTree.

Definition SearchTree'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "key"%go go.uint64);
  (go.FieldDecl "left"%go (go.PointerType SearchTree));
  (go.FieldDecl "right"%go (go.PointerType SearchTree))
].
Program Definition SearchTree'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SearchTree'fds_unsealed).
Global Instance equals_unfold_SearchTree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SearchTree'fds =→ SearchTree'fds_unsealed.
Proof. rewrite /SearchTree'fds seal_eq //. Qed.

Definition SearchTreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SearchTree'fds).

Class SearchTree_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SearchTree_type_repr  :: go.TypeReprUnderlying SearchTreeⁱᵐᵖˡ SearchTree.t;
  #[global] SearchTree_underlying :: (SearchTree) <u (SearchTreeⁱᵐᵖˡ);
  #[global] SearchTree_get_key (x : SearchTree.t) :: ⟦StructFieldGet (SearchTreeⁱᵐᵖˡ) "key", #x⟧ ⤳[under] #x.(SearchTree.key');
  #[global] SearchTree_set_key (x : SearchTree.t) y :: ⟦StructFieldSet (SearchTreeⁱᵐᵖˡ) "key", (#x, #y)⟧ ⤳[under] #(x <|SearchTree.key' := y|>);
  #[global] SearchTree_get_left (x : SearchTree.t) :: ⟦StructFieldGet (SearchTreeⁱᵐᵖˡ) "left", #x⟧ ⤳[under] #x.(SearchTree.left');
  #[global] SearchTree_set_left (x : SearchTree.t) y :: ⟦StructFieldSet (SearchTreeⁱᵐᵖˡ) "left", (#x, #y)⟧ ⤳[under] #(x <|SearchTree.left' := y|>);
  #[global] SearchTree_get_right (x : SearchTree.t) :: ⟦StructFieldGet (SearchTreeⁱᵐᵖˡ) "right", #x⟧ ⤳[under] #x.(SearchTree.right');
  #[global] SearchTree_set_right (x : SearchTree.t) y :: ⟦StructFieldSet (SearchTreeⁱᵐᵖˡ) "right", (#x, #y)⟧ ⤳[under] #(x <|SearchTree.right' := y|>);
  #[global] SearchTree'ptr_Contains_unfold :: MethodUnfold (go.PointerType (SearchTree)) "Contains" (SearchTree__Containsⁱᵐᵖˡ);
  #[global] SearchTree'ptr_Insert_unfold :: MethodUnfold (go.PointerType (SearchTree)) "Insert" (SearchTree__Insertⁱᵐᵖˡ);
}.

Module Person.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  FirstName' : go_string;
  LastName' : go_string;
  Age' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Person.

Definition Person'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "FirstName"%go go.string);
  (go.FieldDecl "LastName"%go go.string);
  (go.FieldDecl "Age"%go go.uint64)
].
Program Definition Person'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Person'fds_unsealed).
Global Instance equals_unfold_Person {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Person'fds =→ Person'fds_unsealed.
Proof. rewrite /Person'fds seal_eq //. Qed.

Definition Personⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Person'fds).

Class Person_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Person_type_repr  :: go.TypeReprUnderlying Personⁱᵐᵖˡ Person.t;
  #[global] Person_underlying :: (Person) <u (Personⁱᵐᵖˡ);
  #[global] Person_get_FirstName (x : Person.t) :: ⟦StructFieldGet (Personⁱᵐᵖˡ) "FirstName", #x⟧ ⤳[under] #x.(Person.FirstName');
  #[global] Person_set_FirstName (x : Person.t) y :: ⟦StructFieldSet (Personⁱᵐᵖˡ) "FirstName", (#x, #y)⟧ ⤳[under] #(x <|Person.FirstName' := y|>);
  #[global] Person_get_LastName (x : Person.t) :: ⟦StructFieldGet (Personⁱᵐᵖˡ) "LastName", #x⟧ ⤳[under] #x.(Person.LastName');
  #[global] Person_set_LastName (x : Person.t) y :: ⟦StructFieldSet (Personⁱᵐᵖˡ) "LastName", (#x, #y)⟧ ⤳[under] #(x <|Person.LastName' := y|>);
  #[global] Person_get_Age (x : Person.t) :: ⟦StructFieldGet (Personⁱᵐᵖˡ) "Age", #x⟧ ⤳[under] #x.(Person.Age');
  #[global] Person_set_Age (x : Person.t) y :: ⟦StructFieldSet (Personⁱᵐᵖˡ) "Age", (#x, #y)⟧ ⤳[under] #(x <|Person.Age' := y|>);
  #[global] Person_BuggySetAge_unfold :: MethodUnfold (Person) "BuggySetAge" (Person__BuggySetAgeⁱᵐᵖˡ);
  #[global] Person_Name_unfold :: MethodUnfold (Person) "Name" (Person__Nameⁱᵐᵖˡ);
  #[global] Person'ptr_BuggySetAge_unfold :: MethodUnfold (go.PointerType (Person)) "BuggySetAge" (λ: "$r", MethodResolve (Person) "BuggySetAge" (![(Person)] "$r"));
  #[global] Person'ptr_GetAge_unfold :: MethodUnfold (go.PointerType (Person)) "GetAge" (Person__GetAgeⁱᵐᵖˡ);
  #[global] Person'ptr_Name_unfold :: MethodUnfold (go.PointerType (Person)) "Name" (λ: "$r", MethodResolve (Person) "Name" (![(Person)] "$r"));
  #[global] Person'ptr_Older_unfold :: MethodUnfold (go.PointerType (Person)) "Older" (Person__Olderⁱᵐᵖˡ);
}.

Module Rect.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Width' : w64;
  Height' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Rect.

Definition Rect'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Width"%go go.uint64);
  (go.FieldDecl "Height"%go go.uint64)
].
Program Definition Rect'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Rect'fds_unsealed).
Global Instance equals_unfold_Rect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Rect'fds =→ Rect'fds_unsealed.
Proof. rewrite /Rect'fds seal_eq //. Qed.

Definition Rectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Rect'fds).

Class Rect_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Rect_type_repr  :: go.TypeReprUnderlying Rectⁱᵐᵖˡ Rect.t;
  #[global] Rect_underlying :: (Rect) <u (Rectⁱᵐᵖˡ);
  #[global] Rect_get_Width (x : Rect.t) :: ⟦StructFieldGet (Rectⁱᵐᵖˡ) "Width", #x⟧ ⤳[under] #x.(Rect.Width');
  #[global] Rect_set_Width (x : Rect.t) y :: ⟦StructFieldSet (Rectⁱᵐᵖˡ) "Width", (#x, #y)⟧ ⤳[under] #(x <|Rect.Width' := y|>);
  #[global] Rect_get_Height (x : Rect.t) :: ⟦StructFieldGet (Rectⁱᵐᵖˡ) "Height", #x⟧ ⤳[under] #x.(Rect.Height');
  #[global] Rect_set_Height (x : Rect.t) y :: ⟦StructFieldSet (Rectⁱᵐᵖˡ) "Height", (#x, #y)⟧ ⤳[under] #(x <|Rect.Height' := y|>);
  #[global] Rect'ptr_Area_unfold :: MethodUnfold (go.PointerType (Rect)) "Area" (Rect__Areaⁱᵐᵖˡ);
  #[global] Rect'ptr_MakeSquare_unfold :: MethodUnfold (go.PointerType (Rect)) "MakeSquare" (Rect__MakeSquareⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S1_instance :: S1_Assumptions;
  #[global] Stack_instance :: Stack_Assumptions;
  #[global] Queue_instance :: Queue_Assumptions;
  #[global] SearchTree_instance :: SearchTree_Assumptions;
  #[global] Person_instance :: Person_Assumptions;
  #[global] Rect_instance :: Rect_Assumptions;
  #[global] BinarySearch_unfold :: FuncUnfold BinarySearch [] (BinarySearchⁱᵐᵖˡ);
  #[global] ExampleA_unfold :: FuncUnfold ExampleA [] (ExampleAⁱᵐᵖˡ);
  #[global] ExampleB_unfold :: FuncUnfold ExampleB [] (ExampleBⁱᵐᵖˡ);
  #[global] ExampleC_unfold :: FuncUnfold ExampleC [] (ExampleCⁱᵐᵖˡ);
  #[global] ExampleD_unfold :: FuncUnfold ExampleD [] (ExampleDⁱᵐᵖˡ);
  #[global] ExampleE_unfold :: FuncUnfold ExampleE [] (ExampleEⁱᵐᵖˡ);
  #[global] collatzF_unfold :: FuncUnfold collatzF [] (collatzFⁱᵐᵖˡ);
  #[global] collatzIter_unfold :: FuncUnfold collatzIter [] (collatzIterⁱᵐᵖˡ);
  #[global] ExampleG_unfold :: FuncUnfold ExampleG [] (ExampleGⁱᵐᵖˡ);
  #[global] Swap_unfold :: FuncUnfold Swap [] (Swapⁱᵐᵖˡ);
  #[global] IgnoreOne_unfold :: FuncUnfold IgnoreOne [] (IgnoreOneⁱᵐᵖˡ);
  #[global] UseIgnoreOneOwnership_unfold :: FuncUnfold UseIgnoreOneOwnership [] (UseIgnoreOneOwnershipⁱᵐᵖˡ);
  #[global] CopySlice_unfold :: FuncUnfold CopySlice [] (CopySliceⁱᵐᵖˡ);
  #[global] StackEscape_unfold :: FuncUnfold StackEscape [] (StackEscapeⁱᵐᵖˡ);
  #[global] SliceSwap_unfold :: FuncUnfold SliceSwap [] (SliceSwapⁱᵐᵖˡ);
  #[global] FindMajority_unfold :: FuncUnfold FindMajority [] (FindMajorityⁱᵐᵖˡ);
  #[global] NewStack_unfold :: FuncUnfold NewStack [] (NewStackⁱᵐᵖˡ);
  #[global] NewQueue_unfold :: FuncUnfold NewQueue [] (NewQueueⁱᵐᵖˡ);
  #[global] NewSearchTree_unfold :: FuncUnfold NewSearchTree [] (NewSearchTreeⁱᵐᵖˡ);
  #[global] singletonTree_unfold :: FuncUnfold singletonTree [] (singletonTreeⁱᵐᵖˡ);
  #[global] ExamplePerson_unfold :: FuncUnfold ExamplePerson [] (ExamplePersonⁱᵐᵖˡ);
  #[global] ExamplePersonRef_unfold :: FuncUnfold ExamplePersonRef [] (ExamplePersonRefⁱᵐᵖˡ);
  #[global] IsSquare_unfold :: FuncUnfold IsSquare [] (IsSquareⁱᵐᵖˡ);
  #[global] Rotate_unfold :: FuncUnfold Rotate [] (Rotateⁱᵐᵖˡ);
  #[global] import_std_Assumption :: std.Assumptions;
}.
End heap.
