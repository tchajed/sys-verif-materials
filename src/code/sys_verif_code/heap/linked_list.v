(* autogenerated from sys_verif_code/heap/linked_list *)
From New.golang Require Import defn.
Module pkg_id.
Definition linked_list : go_string := "sys_verif_code/heap/linked_list".

End pkg_id.
Export pkg_id.
Module linked_list.

Definition Node {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/heap/linked_list.Node"%go [].

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/heap/linked_list.New"%go.

(* go: linked_list.go:8:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Convert go.untyped_nil (go.PointerType Node) UntypedNil)).

(* go: linked_list.go:12:16 *)
Definition Node__Insertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (GoAlloc (go.PointerType Node) "l") in
    let: "elem" := (GoAlloc go.uint64 "elem") in
    return: (GoAlloc Node (let: "$v0" := (![go.uint64] "elem") in
     let: "$v1" := (![go.PointerType Node] "l") in
     CompositeLiteral Node (LiteralValue [KeyedElement (Some (KeyField "elem"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "next"%go)) (ElementExpression (go.PointerType Node) "$v1")])))).

(* go: linked_list.go:16:16 *)
Definition Node__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Node) "l") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType Node] "l") =⟨go.PointerType Node⟩ (Convert go.untyped_nil (go.PointerType Node) UntypedNil))
    then return: (#(W64 0), ![go.PointerType Node] "l", #false)
    else do:  #());;;
    return: (![go.uint64] (StructFieldRef Node "elem"%go (![go.PointerType Node] "l")), ![go.PointerType Node] (StructFieldRef Node "next"%go (![go.PointerType Node] "l")), #true)).

(* go: linked_list.go:23:16 *)
Definition Node__Containsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (GoAlloc (go.PointerType Node) "l") in
    let: "elem" := (GoAlloc go.uint64 "elem") in
    let: "n" := (GoAlloc (go.PointerType Node) (GoZeroVal (go.PointerType Node) #())) in
    let: "$r0" := (![go.PointerType Node] "l") in
    do:  ("n" <-[go.PointerType Node] "$r0");;;
    (for: (λ: <>, (![go.PointerType Node] "n") ≠⟨go.PointerType Node⟩ (Convert go.untyped_nil (go.PointerType Node) UntypedNil)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Node "elem"%go (![go.PointerType Node] "n"))) =⟨go.uint64⟩ (![go.uint64] "elem"))
      then return: (#true)
      else do:  #());;;
      let: "$r0" := (![go.PointerType Node] (StructFieldRef Node "next"%go (![go.PointerType Node] "n"))) in
      do:  ("n" <-[go.PointerType Node] "$r0"));;;
    return: (#false)).

(* go: linked_list.go:34:16 *)
Definition Node__Deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "elem",
    exception_do (let: "l" := (GoAlloc (go.PointerType Node) "l") in
    let: "elem" := (GoAlloc go.uint64 "elem") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType Node] "l") =⟨go.PointerType Node⟩ (Convert go.untyped_nil (go.PointerType Node) UntypedNil))
    then return: (![go.PointerType Node] "l")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Node "elem"%go (![go.PointerType Node] "l"))) =⟨go.uint64⟩ (![go.uint64] "elem"))
    then
      return: (let: "$a0" := (![go.uint64] "elem") in
       (MethodResolve (go.PointerType Node) "Delete"%go (![go.PointerType Node] (StructFieldRef Node "next"%go (![go.PointerType Node] "l")))) "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![go.uint64] "elem") in
    (MethodResolve (go.PointerType Node) "Delete"%go (![go.PointerType Node] (StructFieldRef Node "next"%go (![go.PointerType Node] "l")))) "$a0") in
    do:  ((StructFieldRef Node "next"%go (![go.PointerType Node] "l")) <-[go.PointerType Node] "$r0");;;
    return: (![go.PointerType Node] "l")).

(* go: linked_list.go:46:16 *)
Definition Node__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "other",
    exception_do (let: "l" := (GoAlloc (go.PointerType Node) "l") in
    let: "other" := (GoAlloc (go.PointerType Node) "other") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType Node] "l") =⟨go.PointerType Node⟩ (Convert go.untyped_nil (go.PointerType Node) UntypedNil))
    then return: (![go.PointerType Node] "other")
    else do:  #());;;
    return: (GoAlloc Node (let: "$v0" := (![go.uint64] (StructFieldRef Node "elem"%go (![go.PointerType Node] "l"))) in
     let: "$v1" := (let: "$a0" := (![go.PointerType Node] "other") in
     (MethodResolve (go.PointerType Node) "Append"%go (![go.PointerType Node] (StructFieldRef Node "next"%go (![go.PointerType Node] "l")))) "$a0") in
     CompositeLiteral Node (LiteralValue [KeyedElement (Some (KeyField "elem"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "next"%go)) (ElementExpression (go.PointerType Node) "$v1")])))).

#[global] Instance info' : PkgInfo pkg_id.linked_list :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.linked_list (λ: <>,
      exception_do (do:  #())
      ).

Module Node.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  elem' : w64;
  next' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Node.

Definition Node'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "elem"%go go.uint64);
  (go.FieldDecl "next"%go (go.PointerType Node))
].
Program Definition Node'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Node'fds_unsealed).
Global Instance equals_unfold_Node {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Node'fds =→ Node'fds_unsealed.
Proof. rewrite /Node'fds seal_eq //. Qed.

Definition Nodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Node'fds).

Class Node_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Node_type_repr  :: go.TypeReprUnderlying Nodeⁱᵐᵖˡ Node.t;
  #[global] Node_underlying :: (Node) <u (Nodeⁱᵐᵖˡ);
  #[global] Node_get_elem (x : Node.t) :: ⟦StructFieldGet (Nodeⁱᵐᵖˡ) "elem", #x⟧ ⤳[under] #x.(Node.elem');
  #[global] Node_set_elem (x : Node.t) y :: ⟦StructFieldSet (Nodeⁱᵐᵖˡ) "elem", (#x, #y)⟧ ⤳[under] #(x <|Node.elem' := y|>);
  #[global] Node_get_next (x : Node.t) :: ⟦StructFieldGet (Nodeⁱᵐᵖˡ) "next", #x⟧ ⤳[under] #x.(Node.next');
  #[global] Node_set_next (x : Node.t) y :: ⟦StructFieldSet (Nodeⁱᵐᵖˡ) "next", (#x, #y)⟧ ⤳[under] #(x <|Node.next' := y|>);
  #[global] Node'ptr_Append_unfold :: MethodUnfold (go.PointerType (Node)) "Append" (Node__Appendⁱᵐᵖˡ);
  #[global] Node'ptr_Contains_unfold :: MethodUnfold (go.PointerType (Node)) "Contains" (Node__Containsⁱᵐᵖˡ);
  #[global] Node'ptr_Delete_unfold :: MethodUnfold (go.PointerType (Node)) "Delete" (Node__Deleteⁱᵐᵖˡ);
  #[global] Node'ptr_Insert_unfold :: MethodUnfold (go.PointerType (Node)) "Insert" (Node__Insertⁱᵐᵖˡ);
  #[global] Node'ptr_Pop_unfold :: MethodUnfold (go.PointerType (Node)) "Pop" (Node__Popⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Node_instance :: Node_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
}.
End linked_list.
