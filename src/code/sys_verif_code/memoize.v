(* autogenerated from sys_verif_code/memoize *)
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition memoize : go_string := "sys_verif_code/memoize".

End pkg_id.
Export pkg_id.
Module memoize.

Definition Memoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/memoize.Memoize"%go [].

Definition MockMemoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/memoize.MockMemoize"%go [].

Definition NewMemoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/memoize.NewMemoize"%go.

Definition UseMemoize1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/memoize.UseMemoize1"%go.

Definition UseMemoize2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/memoize.UseMemoize2"%go.

Definition NewMockMemoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/memoize.NewMockMemoize"%go.

(* go: memoize.go:11:6 *)
Definition NewMemoizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "f") in
    return: (let: "$v0" := (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "f") in
     let: "$v1" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
     CompositeLiteral Memoize (LiteralValue [KeyedElement (Some (KeyField "f"%go)) (ElementExpression (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "$v0"); KeyedElement (Some (KeyField "results"%go)) (ElementExpression (go.MapType go.uint64 go.uint64) "$v1")]))).

(* go: memoize.go:18:18 *)
Definition Memoize__Callⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "x",
    exception_do (let: "m" := (GoAlloc Memoize "m") in
    let: "x" := (GoAlloc go.uint64 "x") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cached" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.uint64 (![go.MapType go.uint64 go.uint64] (StructFieldRef Memoize "results"%go "m")) (![go.uint64] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cached" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "cached")
    else do:  #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "x") in
    (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] (StructFieldRef Memoize "f"%go "m")) "$a0") in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "y") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] (StructFieldRef Memoize "results"%go "m")) (![go.uint64] "x") "$r0");;;
    return: (![go.uint64] "y")).

(* go: memoize.go:28:6 *)
Definition UseMemoize1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc Memoize (GoZeroVal Memoize #())) in
    let: "$r0" := (let: "$a0" := (λ: "x",
      exception_do (let: "x" := (GoAlloc go.uint64 "x") in
      return: ((![go.uint64] "x") *⟨go.uint64⟩ (![go.uint64] "x")))
      ) in
    (FuncResolve NewMemoize [] #()) "$a0") in
    do:  ("m" <-[Memoize] "$r0");;;
    let: "y1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 3) in
    (MethodResolve Memoize "Call"%go (![Memoize] "m")) "$a0") in
    do:  ("y1" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := ((![go.uint64] "y1") =⟨go.uint64⟩ #(W64 9)) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "y2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 3) in
    (MethodResolve Memoize "Call"%go (![Memoize] "m")) "$a0") in
    do:  ("y2" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := ((![go.uint64] "y2") =⟨go.uint64⟩ #(W64 9)) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "y3" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 5) in
    (MethodResolve Memoize "Call"%go (![Memoize] "m")) "$a0") in
    do:  ("y3" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := ((![go.uint64] "y3") =⟨go.uint64⟩ #(W64 25)) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: #()).

(* go: memoize.go:40:6 *)
Definition UseMemoize2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "sumUpto" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) (GoZeroVal (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) #())) in
    let: "$r0" := (λ: "n",
      exception_do (let: "n" := (GoAlloc go.uint64 "n") in
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") >⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")))
      then return: (#(W64 0))
      else do:  #());;;
      let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", Convert go.uint64 go.int (![go.uint64] "i"))))))));;;
      return: (![go.uint64] "sum"))
      ) in
    do:  ("sumUpto" <-[go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "$r0");;;
    let: "m" := (GoAlloc Memoize (GoZeroVal Memoize #())) in
    let: "$r0" := (let: "$a0" := (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "sumUpto") in
    (FuncResolve NewMemoize [] #()) "$a0") in
    do:  ("m" <-[Memoize] "$r0");;;
    let: "y1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 3) in
    (MethodResolve Memoize "Call"%go (![Memoize] "m")) "$a0") in
    do:  ("y1" <-[go.uint64] "$r0");;;
    let: "y2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 3) in
    (MethodResolve Memoize "Call"%go (![Memoize] "m")) "$a0") in
    do:  ("y2" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := ((![go.uint64] "y1") =⟨go.uint64⟩ (![go.uint64] "y2")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: #()).

(* go: memoize.go:64:6 *)
Definition NewMockMemoizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "f") in
    return: (GoAlloc MockMemoize (let: "$v0" := (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "f") in
     CompositeLiteral MockMemoize (LiteralValue [KeyedElement (Some (KeyField "f"%go)) (ElementExpression (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "$v0")])))).

(* go: memoize.go:68:23 *)
Definition MockMemoize__Callⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "x",
    exception_do (let: "m" := (GoAlloc (go.PointerType MockMemoize) "m") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (let: "$a0" := (![go.uint64] "x") in
     (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] (StructFieldRef MockMemoize "f"%go (![go.PointerType MockMemoize] "m"))) "$a0")).

#[global] Instance info' : PkgInfo pkg_id.memoize :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.memoize (λ: <>,
      exception_do (do:  (std.initialize' #()))
      ).

Module Memoize.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f' : func.t;
  results' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Memoize.

Definition Memoize'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [go.uint64] false [go.uint64])));
  (go.FieldDecl "results"%go (go.MapType go.uint64 go.uint64))
].
Program Definition Memoize'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Memoize'fds_unsealed).
Global Instance equals_unfold_Memoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Memoize'fds =→ Memoize'fds_unsealed.
Proof. rewrite /Memoize'fds seal_eq //. Qed.

Definition Memoizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Memoize'fds).

Class Memoize_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Memoize_type_repr  :: go.TypeReprUnderlying Memoizeⁱᵐᵖˡ Memoize.t;
  #[global] Memoize_underlying :: (Memoize) <u (Memoizeⁱᵐᵖˡ);
  #[global] Memoize_get_f (x : Memoize.t) :: ⟦StructFieldGet (Memoizeⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(Memoize.f');
  #[global] Memoize_set_f (x : Memoize.t) y :: ⟦StructFieldSet (Memoizeⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|Memoize.f' := y|>);
  #[global] Memoize_get_results (x : Memoize.t) :: ⟦StructFieldGet (Memoizeⁱᵐᵖˡ) "results", #x⟧ ⤳[under] #x.(Memoize.results');
  #[global] Memoize_set_results (x : Memoize.t) y :: ⟦StructFieldSet (Memoizeⁱᵐᵖˡ) "results", (#x, #y)⟧ ⤳[under] #(x <|Memoize.results' := y|>);
  #[global] Memoize_Call_unfold :: MethodUnfold (Memoize) "Call" (Memoize__Callⁱᵐᵖˡ);
  #[global] Memoize'ptr_Call_unfold :: MethodUnfold (go.PointerType (Memoize)) "Call" (λ: "$r", MethodResolve (Memoize) "Call" (![(Memoize)] "$r"));
}.

Module MockMemoize.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End MockMemoize.

Definition MockMemoize'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [go.uint64] false [go.uint64])))
].
Program Definition MockMemoize'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (MockMemoize'fds_unsealed).
Global Instance equals_unfold_MockMemoize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : MockMemoize'fds =→ MockMemoize'fds_unsealed.
Proof. rewrite /MockMemoize'fds seal_eq //. Qed.

Definition MockMemoizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (MockMemoize'fds).

Class MockMemoize_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MockMemoize_type_repr  :: go.TypeReprUnderlying MockMemoizeⁱᵐᵖˡ MockMemoize.t;
  #[global] MockMemoize_underlying :: (MockMemoize) <u (MockMemoizeⁱᵐᵖˡ);
  #[global] MockMemoize_get_f (x : MockMemoize.t) :: ⟦StructFieldGet (MockMemoizeⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(MockMemoize.f');
  #[global] MockMemoize_set_f (x : MockMemoize.t) y :: ⟦StructFieldSet (MockMemoizeⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|MockMemoize.f' := y|>);
  #[global] MockMemoize'ptr_Call_unfold :: MethodUnfold (go.PointerType (MockMemoize)) "Call" (MockMemoize__Callⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Memoize_instance :: Memoize_Assumptions;
  #[global] MockMemoize_instance :: MockMemoize_Assumptions;
  #[global] NewMemoize_unfold :: FuncUnfold NewMemoize [] (NewMemoizeⁱᵐᵖˡ);
  #[global] UseMemoize1_unfold :: FuncUnfold UseMemoize1 [] (UseMemoize1ⁱᵐᵖˡ);
  #[global] UseMemoize2_unfold :: FuncUnfold UseMemoize2 [] (UseMemoize2ⁱᵐᵖˡ);
  #[global] NewMockMemoize_unfold :: FuncUnfold NewMockMemoize [] (NewMockMemoizeⁱᵐᵖˡ);
  #[global] import_std_Assumption :: std.Assumptions;
}.
End memoize.
