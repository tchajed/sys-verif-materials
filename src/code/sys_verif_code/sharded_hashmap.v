(* autogenerated from sys_verif_code/sharded_hashmap *)
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition sharded_hashmap : go_string := "sys_verif_code/sharded_hashmap".

End pkg_id.
Export pkg_id.
Module sharded_hashmap.

Definition entry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/sharded_hashmap.entry"%go [].

Definition entryShard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/sharded_hashmap.entryShard"%go [].

Definition bucket {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/sharded_hashmap.bucket"%go [].

Definition HashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sys_verif_code/sharded_hashmap.HashMap"%go [].

Definition hash {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/sharded_hashmap.hash"%go.

Definition newBucket {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/sharded_hashmap.newBucket"%go.

Definition createNewBuckets {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/sharded_hashmap.createNewBuckets"%go.

Definition NewHashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/sharded_hashmap.NewHashMap"%go.

Definition bucketIdx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sys_verif_code/sharded_hashmap.bucketIdx"%go.

(* go: entries.go:17:23 *)
Definition entryShard__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "es" "key",
    exception_do (let: "es" := (GoAlloc (go.PointerType entryShard) "es") in
    let: "key" := (GoAlloc go.uint32 "key") in
    let: "entries" := (GoAlloc (go.SliceType entry) (GoZeroVal (go.SliceType entry) #())) in
    let: "$r0" := (![go.SliceType entry] (StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es"))) in
    do:  ("entries" <-[go.SliceType entry] "$r0");;;
    let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("found" <-[go.bool] "$r0");;;
    let: "val" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("val" <-[go.uint64] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType entry] "entries") in
    (FuncResolve go.len [go.SliceType entry] #()) "$a0"))); (λ: <>, #()) := λ: <>,
      let: "e" := (GoAlloc entry (GoZeroVal entry #())) in
      let: "$r0" := (![entry] (IndexRef (go.SliceType entry) (![go.SliceType entry] "entries", Convert go.uint64 go.int (![go.uint64] "i")))) in
      do:  ("e" <-[entry] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint32] (StructFieldRef entry "key"%go "e")) =⟨go.uint32⟩ (![go.uint32] "key"))
      then
        let: "$r0" := #true in
        do:  ("found" <-[go.bool] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef entry "val"%go "e")) in
        do:  ("val" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    return: (![go.uint64] "val", ![go.bool] "found")).

(* go: entries.go:34:23 *)
Definition entryShard__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "es" "key" "val",
    exception_do (let: "es" := (GoAlloc (go.PointerType entryShard) "es") in
    let: "val" := (GoAlloc go.uint64 "val") in
    let: "key" := (GoAlloc go.uint32 "key") in
    let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("found" <-[go.bool] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType entry] (StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es"))) in
    (FuncResolve go.len [go.SliceType entry] #()) "$a0")) in
    do:  ("l" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "l")); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint32] (StructFieldRef entry "key"%go (IndexRef (go.SliceType entry) (![go.SliceType entry] (StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es")), Convert go.uint64 go.int (![go.uint64] "i"))))) =⟨go.uint32⟩ (![go.uint32] "key"))
      then
        let: "$r0" := #true in
        do:  ("found" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    (if: ![go.bool] "found"
    then
      let: "$r0" := (let: "$v0" := (![go.uint32] "key") in
      let: "$v1" := (![go.uint64] "val") in
      CompositeLiteral entry (LiteralValue [KeyedElement (Some (KeyField "key"%go)) (ElementExpression go.uint32 "$v0"); KeyedElement (Some (KeyField "val"%go)) (ElementExpression go.uint64 "$v1")])) in
      do:  ((IndexRef (go.SliceType entry) (![go.SliceType entry] (StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es")), Convert go.uint64 go.int (![go.uint64] "i"))) <-[entry] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![go.SliceType entry] (StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$v0" := (![go.uint32] "key") in
      let: "$v1" := (![go.uint64] "val") in
      CompositeLiteral entry (LiteralValue [KeyedElement (Some (KeyField "key"%go)) (ElementExpression go.uint32 "$v0"); KeyedElement (Some (KeyField "val"%go)) (ElementExpression go.uint64 "$v1")])) in
      CompositeLiteral (go.SliceType entry) (LiteralValue [KeyedElement None (ElementExpression entry "$sl0")]))) in
      (FuncResolve go.append [go.SliceType entry] #()) "$a0" "$a1") in
      do:  ((StructFieldRef entryShard "entries"%go (![go.PointerType entryShard] "es")) <-[go.SliceType entry] "$r0"));;;
    return: #()).

(* hash is an arbitrary hash function for uint32

   Goose doesn't expose any real hash function (like hash/fnv or crypto.SHA512),
   so we need to implement our own. The actual hash function doesn't matter for
   correctness, though; it only needs to be deterministic.

   go: sharded_hashmap.go:17:6 *)
Definition hashⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key",
    exception_do (let: "key" := (GoAlloc go.uint32 "key") in
    let: "h" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 5381) in
    do:  ("h" <-[go.uint32] "$r0");;;
    let: "k" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 17000069) in
    do:  ("k" <-[go.uint32] "$r0");;;
    let: "$r0" := (((![go.uint32] "h") *⟨go.uint32⟩ (![go.uint32] "k")) +⟨go.uint32⟩ ((![go.uint32] "key") &⟨go.uint32⟩ #(W32 255))) in
    do:  ("h" <-[go.uint32] "$r0");;;
    let: "$r0" := (((![go.uint32] "h") *⟨go.uint32⟩ (![go.uint32] "k")) +⟨go.uint32⟩ (((![go.uint32] "key") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #8)) &⟨go.uint32⟩ #(W32 255))) in
    do:  ("h" <-[go.uint32] "$r0");;;
    let: "$r0" := (((![go.uint32] "h") *⟨go.uint32⟩ (![go.uint32] "k")) +⟨go.uint32⟩ (((![go.uint32] "key") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #16)) &⟨go.uint32⟩ #(W32 255))) in
    do:  ("h" <-[go.uint32] "$r0");;;
    let: "$r0" := (((![go.uint32] "h") *⟨go.uint32⟩ (![go.uint32] "k")) +⟨go.uint32⟩ (((![go.uint32] "key") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #24)) &⟨go.uint32⟩ #(W32 255))) in
    do:  ("h" <-[go.uint32] "$r0");;;
    return: (![go.uint32] "h")).

(* go: sharded_hashmap.go:40:6 *)
Definition newBucketⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc bucket (let: "$v0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
     let: "$v1" := ((FuncResolve go.make1 [go.MapType go.uint32 go.uint64] #()) #()) in
     CompositeLiteral bucket (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v0"); KeyedElement (Some (KeyField "subMap"%go)) (ElementExpression (go.MapType go.uint32 go.uint64) "$v1")])))).

(* go: sharded_hashmap.go:47:6 *)
Definition createNewBucketsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "newSize",
    exception_do (let: "newSize" := (GoAlloc go.uint32 "newSize") in
    let: "newBuckets" := (GoAlloc (go.SliceType (go.PointerType bucket)) (GoZeroVal (go.SliceType (go.PointerType bucket)) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType (go.PointerType bucket)) (LiteralValue [])) in
    do:  ("newBuckets" <-[go.SliceType (go.PointerType bucket)] "$r0");;;
    let: "numBuckets" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.uint32 go.uint64 (![go.uint32] "newSize")) in
    do:  ("numBuckets" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "numBuckets")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType bucket)] "newBuckets") in
      let: "$a1" := ((let: "$sl0" := ((FuncResolve newBucket [] #()) #()) in
      CompositeLiteral (go.SliceType (go.PointerType bucket)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType bucket) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType bucket)] #()) "$a0" "$a1") in
      do:  ("newBuckets" <-[go.SliceType (go.PointerType bucket)] "$r0")));;;
    return: (![go.SliceType (go.PointerType bucket)] "newBuckets")).

(* NewHashMap creates a hashmap with size buckets.

   Larger size will consume some memory for the additional locks, but will
   improve concurrency by reducing the number of hash collisions.

   go: sharded_hashmap.go:60:6 *)
Definition NewHashMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "size",
    exception_do (let: "size" := (GoAlloc go.uint32 "size") in
    return: (GoAlloc HashMap (let: "$v0" := (let: "$a0" := (![go.uint32] "size") in
     (FuncResolve createNewBuckets [] #()) "$a0") in
     CompositeLiteral HashMap (LiteralValue [KeyedElement (Some (KeyField "buckets"%go)) (ElementExpression (go.SliceType (go.PointerType bucket)) "$v0")])))).

(* go: sharded_hashmap.go:66:6 *)
Definition bucketIdxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key" "numBuckets",
    exception_do (let: "numBuckets" := (GoAlloc go.uint64 "numBuckets") in
    let: "key" := (GoAlloc go.uint32 "key") in
    return: (Convert go.uint32 go.uint64 ((let: "$a0" := (![go.uint32] "key") in
     (FuncResolve hash [] #()) "$a0") %⟨go.uint32⟩ (Convert go.uint64 go.uint32 (![go.uint64] "numBuckets"))))).

(* Load gets a key from the map and returns (v, ok). If ok is false then the key
   was not found.

   go: sharded_hashmap.go:72:20 *)
Definition HashMap__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hm" "key",
    exception_do (let: "hm" := (GoAlloc (go.PointerType HashMap) "hm") in
    let: "key" := (GoAlloc go.uint32 "key") in
    let: "buckets" := (GoAlloc (go.SliceType (go.PointerType bucket)) (GoZeroVal (go.SliceType (go.PointerType bucket)) #())) in
    let: "$r0" := (![go.SliceType (go.PointerType bucket)] (StructFieldRef HashMap "buckets"%go (![go.PointerType HashMap] "hm"))) in
    do:  ("buckets" <-[go.SliceType (go.PointerType bucket)] "$r0");;;
    let: "b" := (GoAlloc (go.PointerType bucket) (GoZeroVal (go.PointerType bucket) #())) in
    let: "$r0" := (![go.PointerType bucket] (IndexRef (go.SliceType (go.PointerType bucket)) (![go.SliceType (go.PointerType bucket)] "buckets", Convert go.uint64 go.int (let: "$a0" := (![go.uint32] "key") in
     let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType bucket)] "buckets") in
     (FuncResolve go.len [go.SliceType (go.PointerType bucket)] #()) "$a0")) in
     (FuncResolve bucketIdx [] #()) "$a0" "$a1")))) in
    do:  ("b" <-[go.PointerType bucket] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef bucket "mu"%go (![go.PointerType bucket] "b")))) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint32 go.uint64 (![go.MapType go.uint32 go.uint64] (StructFieldRef bucket "subMap"%go (![go.PointerType bucket] "b"))) (![go.uint32] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef bucket "mu"%go (![go.PointerType bucket] "b")))) #());;;
    return: (![go.uint64] "x", ![go.bool] "ok")).

(* Store inserts a key into the map.

   go: sharded_hashmap.go:82:20 *)
Definition HashMap__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hm" "key" "val",
    exception_do (let: "hm" := (GoAlloc (go.PointerType HashMap) "hm") in
    let: "val" := (GoAlloc go.uint64 "val") in
    let: "key" := (GoAlloc go.uint32 "key") in
    let: "buckets" := (GoAlloc (go.SliceType (go.PointerType bucket)) (GoZeroVal (go.SliceType (go.PointerType bucket)) #())) in
    let: "$r0" := (![go.SliceType (go.PointerType bucket)] (StructFieldRef HashMap "buckets"%go (![go.PointerType HashMap] "hm"))) in
    do:  ("buckets" <-[go.SliceType (go.PointerType bucket)] "$r0");;;
    let: "b" := (GoAlloc (go.PointerType bucket) (GoZeroVal (go.PointerType bucket) #())) in
    let: "$r0" := (![go.PointerType bucket] (IndexRef (go.SliceType (go.PointerType bucket)) (![go.SliceType (go.PointerType bucket)] "buckets", Convert go.uint64 go.int (let: "$a0" := (![go.uint32] "key") in
     let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType bucket)] "buckets") in
     (FuncResolve go.len [go.SliceType (go.PointerType bucket)] #()) "$a0")) in
     (FuncResolve bucketIdx [] #()) "$a0" "$a1")))) in
    do:  ("b" <-[go.PointerType bucket] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef bucket "mu"%go (![go.PointerType bucket] "b")))) #());;;
    let: "$r0" := (![go.uint64] "val") in
    do:  (map.insert go.uint32 (![go.MapType go.uint32 go.uint64] (StructFieldRef bucket "subMap"%go (![go.PointerType bucket] "b"))) (![go.uint32] "key") "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef bucket "mu"%go (![go.PointerType bucket] "b")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.sharded_hashmap :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.sharded_hashmap (λ: <>,
      exception_do (do:  (sync.initialize' #()))
      ).

Module entry.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  key' : w32;
  val' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End entry.

Definition entry'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "key"%go go.uint32);
  (go.FieldDecl "val"%go go.uint64)
].
Program Definition entry'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (entry'fds_unsealed).
Global Instance equals_unfold_entry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : entry'fds =→ entry'fds_unsealed.
Proof. rewrite /entry'fds seal_eq //. Qed.

Definition entryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (entry'fds).

Class entry_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entry_type_repr  :: go.TypeReprUnderlying entryⁱᵐᵖˡ entry.t;
  #[global] entry_underlying :: (entry) <u (entryⁱᵐᵖˡ);
  #[global] entry_get_key (x : entry.t) :: ⟦StructFieldGet (entryⁱᵐᵖˡ) "key", #x⟧ ⤳[under] #x.(entry.key');
  #[global] entry_set_key (x : entry.t) y :: ⟦StructFieldSet (entryⁱᵐᵖˡ) "key", (#x, #y)⟧ ⤳[under] #(x <|entry.key' := y|>);
  #[global] entry_get_val (x : entry.t) :: ⟦StructFieldGet (entryⁱᵐᵖˡ) "val", #x⟧ ⤳[under] #x.(entry.val');
  #[global] entry_set_val (x : entry.t) y :: ⟦StructFieldSet (entryⁱᵐᵖˡ) "val", (#x, #y)⟧ ⤳[under] #(x <|entry.val' := y|>);
}.

Module entryShard.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  entries' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End entryShard.

Definition entryShard'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "entries"%go (go.SliceType entry))
].
Program Definition entryShard'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (entryShard'fds_unsealed).
Global Instance equals_unfold_entryShard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : entryShard'fds =→ entryShard'fds_unsealed.
Proof. rewrite /entryShard'fds seal_eq //. Qed.

Definition entryShardⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (entryShard'fds).

Class entryShard_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entryShard_type_repr  :: go.TypeReprUnderlying entryShardⁱᵐᵖˡ entryShard.t;
  #[global] entryShard_underlying :: (entryShard) <u (entryShardⁱᵐᵖˡ);
  #[global] entryShard_get_entries (x : entryShard.t) :: ⟦StructFieldGet (entryShardⁱᵐᵖˡ) "entries", #x⟧ ⤳[under] #x.(entryShard.entries');
  #[global] entryShard_set_entries (x : entryShard.t) y :: ⟦StructFieldSet (entryShardⁱᵐᵖˡ) "entries", (#x, #y)⟧ ⤳[under] #(x <|entryShard.entries' := y|>);
  #[global] entryShard'ptr_Get_unfold :: MethodUnfold (go.PointerType (entryShard)) "Get" (entryShard__Getⁱᵐᵖˡ);
  #[global] entryShard'ptr_Store_unfold :: MethodUnfold (go.PointerType (entryShard)) "Store" (entryShard__Storeⁱᵐᵖˡ);
}.

Module bucket.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  subMap' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End bucket.

Definition bucket'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "subMap"%go (go.MapType go.uint32 go.uint64))
].
Program Definition bucket'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (bucket'fds_unsealed).
Global Instance equals_unfold_bucket {ext : ffi_syntax} {go_gctx : GoGlobalContext} : bucket'fds =→ bucket'fds_unsealed.
Proof. rewrite /bucket'fds seal_eq //. Qed.

Definition bucketⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (bucket'fds).

Class bucket_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bucket_type_repr  :: go.TypeReprUnderlying bucketⁱᵐᵖˡ bucket.t;
  #[global] bucket_underlying :: (bucket) <u (bucketⁱᵐᵖˡ);
  #[global] bucket_get_mu (x : bucket.t) :: ⟦StructFieldGet (bucketⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(bucket.mu');
  #[global] bucket_set_mu (x : bucket.t) y :: ⟦StructFieldSet (bucketⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|bucket.mu' := y|>);
  #[global] bucket_get_subMap (x : bucket.t) :: ⟦StructFieldGet (bucketⁱᵐᵖˡ) "subMap", #x⟧ ⤳[under] #x.(bucket.subMap');
  #[global] bucket_set_subMap (x : bucket.t) y :: ⟦StructFieldSet (bucketⁱᵐᵖˡ) "subMap", (#x, #y)⟧ ⤳[under] #(x <|bucket.subMap' := y|>);
}.

Module HashMap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  buckets' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End HashMap.

Definition HashMap'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "buckets"%go (go.SliceType (go.PointerType bucket)))
].
Program Definition HashMap'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (HashMap'fds_unsealed).
Global Instance equals_unfold_HashMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : HashMap'fds =→ HashMap'fds_unsealed.
Proof. rewrite /HashMap'fds seal_eq //. Qed.

Definition HashMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (HashMap'fds).

Class HashMap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HashMap_type_repr  :: go.TypeReprUnderlying HashMapⁱᵐᵖˡ HashMap.t;
  #[global] HashMap_underlying :: (HashMap) <u (HashMapⁱᵐᵖˡ);
  #[global] HashMap_get_buckets (x : HashMap.t) :: ⟦StructFieldGet (HashMapⁱᵐᵖˡ) "buckets", #x⟧ ⤳[under] #x.(HashMap.buckets');
  #[global] HashMap_set_buckets (x : HashMap.t) y :: ⟦StructFieldSet (HashMapⁱᵐᵖˡ) "buckets", (#x, #y)⟧ ⤳[under] #(x <|HashMap.buckets' := y|>);
  #[global] HashMap'ptr_Load_unfold :: MethodUnfold (go.PointerType (HashMap)) "Load" (HashMap__Loadⁱᵐᵖˡ);
  #[global] HashMap'ptr_Store_unfold :: MethodUnfold (go.PointerType (HashMap)) "Store" (HashMap__Storeⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entry_instance :: entry_Assumptions;
  #[global] entryShard_instance :: entryShard_Assumptions;
  #[global] bucket_instance :: bucket_Assumptions;
  #[global] HashMap_instance :: HashMap_Assumptions;
  #[global] hash_unfold :: FuncUnfold hash [] (hashⁱᵐᵖˡ);
  #[global] newBucket_unfold :: FuncUnfold newBucket [] (newBucketⁱᵐᵖˡ);
  #[global] createNewBuckets_unfold :: FuncUnfold createNewBuckets [] (createNewBucketsⁱᵐᵖˡ);
  #[global] NewHashMap_unfold :: FuncUnfold NewHashMap [] (NewHashMapⁱᵐᵖˡ);
  #[global] bucketIdx_unfold :: FuncUnfold bucketIdx [] (bucketIdxⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End sharded_hashmap.
