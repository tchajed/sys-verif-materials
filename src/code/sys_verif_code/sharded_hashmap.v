(* autogenerated from sys_verif_code/sharded_hashmap *)
Require Export New.code.sync.

From New.golang Require Import defn.
Definition sharded_hashmap : go_string := "sys_verif_code/sharded_hashmap".

Module sharded_hashmap.

Module entry. Definition id : go_string := "sys_verif_code/sharded_hashmap.entry"%go. End entry.
Module entryShard. Definition id : go_string := "sys_verif_code/sharded_hashmap.entryShard"%go. End entryShard.
Module bucket. Definition id : go_string := "sys_verif_code/sharded_hashmap.bucket"%go. End bucket.
Module HashMap. Definition id : go_string := "sys_verif_code/sharded_hashmap.HashMap"%go. End HashMap.

Section code.
Context `{ffi_syntax}.


Definition entry : go_type := structT [
  "key" :: uint32T;
  "val" :: uint64T
].
#[global] Typeclasses Opaque entry.
#[global] Opaque entry.

Definition entryShard : go_type := structT [
  "entries" :: sliceT
].
#[global] Typeclasses Opaque entryShard.
#[global] Opaque entryShard.

(* go: entries.go:17:23 *)
Definition entryShard__Getⁱᵐᵖˡ : val :=
  λ: "es" "key",
    exception_do (let: "es" := (mem.alloc "es") in
    let: "key" := (mem.alloc "key") in
    let: "entries" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #entryShard #"entries"%go (![#ptrT] "es"))) in
    do:  ("entries" <-[#sliceT] "$r0");;;
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[#boolT] "$r0");;;
    let: "val" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("val" <-[#uint64T] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "entries") in
    slice.len "$a0"))); (λ: <>, #()) := λ: <>,
      let: "e" := (mem.alloc (type.zero_val #entry)) in
      let: "$r0" := (![#entry] (slice.elem_ref #entry (![#sliceT] "entries") (![#uint64T] "i"))) in
      do:  ("e" <-[#entry] "$r0");;;
      (if: (![#uint32T] (struct.field_ref #entry #"key"%go "e")) = (![#uint32T] "key")
      then
        let: "$r0" := #true in
        do:  ("found" <-[#boolT] "$r0");;;
        let: "$r0" := (![#uint64T] (struct.field_ref #entry #"val"%go "e")) in
        do:  ("val" <-[#uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#uint64T] "val", ![#boolT] "found")).

(* go: entries.go:34:23 *)
Definition entryShard__Storeⁱᵐᵖˡ : val :=
  λ: "es" "key" "val",
    exception_do (let: "es" := (mem.alloc "es") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[#boolT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #entryShard #"entries"%go (![#ptrT] "es"))) in
    slice.len "$a0")) in
    do:  ("l" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "l")); (λ: <>, #()) := λ: <>,
      (if: (![#uint32T] (struct.field_ref #entry #"key"%go (slice.elem_ref #entry (![#sliceT] (struct.field_ref #entryShard #"entries"%go (![#ptrT] "es"))) (![#uint64T] "i")))) = (![#uint32T] "key")
      then
        let: "$r0" := #true in
        do:  ("found" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    (if: ![#boolT] "found"
    then
      let: "$r0" := (let: "$key" := (![#uint32T] "key") in
      let: "$val" := (![#uint64T] "val") in
      struct.make #entry [{
        "key" ::= "$key";
        "val" ::= "$val"
      }]) in
      do:  ((slice.elem_ref #entry (![#sliceT] (struct.field_ref #entryShard #"entries"%go (![#ptrT] "es"))) (![#uint64T] "i")) <-[#entry] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #entryShard #"entries"%go (![#ptrT] "es"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$key" := (![#uint32T] "key") in
      let: "$val" := (![#uint64T] "val") in
      struct.make #entry [{
        "key" ::= "$key";
        "val" ::= "$val"
      }]) in
      slice.literal #entry ["$sl0"])) in
      (slice.append #entry) "$a0" "$a1") in
      do:  ((struct.field_ref #entryShard #"entries"%go (![#ptrT] "es")) <-[#sliceT] "$r0"));;;
    return: #()).

Definition hash : go_string := "sys_verif_code/sharded_hashmap.hash"%go.

(* hash is an arbitrary hash function for uint32

   Goose doesn't expose any real hash function (like hash/fnv or crypto.SHA512),
   so we need to implement our own. The actual hash function doesn't matter for
   correctness, though; it only needs to be deterministic.

   go: sharded_hashmap.go:17:6 *)
Definition hashⁱᵐᵖˡ : val :=
  λ: "key",
    exception_do (let: "key" := (mem.alloc "key") in
    let: "h" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := #(W32 5381) in
    do:  ("h" <-[#uint32T] "$r0");;;
    let: "k" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := #(W32 17000069) in
    do:  ("k" <-[#uint32T] "$r0");;;
    let: "$r0" := (((![#uint32T] "h") * (![#uint32T] "k")) + ((![#uint32T] "key") `and` #(W32 255))) in
    do:  ("h" <-[#uint32T] "$r0");;;
    let: "$r0" := (((![#uint32T] "h") * (![#uint32T] "k")) + (((![#uint32T] "key") ≫ #(W32 8)) `and` #(W32 255))) in
    do:  ("h" <-[#uint32T] "$r0");;;
    let: "$r0" := (((![#uint32T] "h") * (![#uint32T] "k")) + (((![#uint32T] "key") ≫ #(W32 16)) `and` #(W32 255))) in
    do:  ("h" <-[#uint32T] "$r0");;;
    let: "$r0" := (((![#uint32T] "h") * (![#uint32T] "k")) + (((![#uint32T] "key") ≫ #(W32 24)) `and` #(W32 255))) in
    do:  ("h" <-[#uint32T] "$r0");;;
    return: (![#uint32T] "h")).

Definition bucket : go_type := structT [
  "mu" :: ptrT;
  "subMap" :: mapT uint32T uint64T
].
#[global] Typeclasses Opaque bucket.
#[global] Opaque bucket.

Definition HashMap : go_type := structT [
  "buckets" :: sliceT
].
#[global] Typeclasses Opaque HashMap.
#[global] Opaque HashMap.

Definition newBucket : go_string := "sys_verif_code/sharded_hashmap.newBucket"%go.

(* go: sharded_hashmap.go:40:6 *)
Definition newBucketⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$subMap" := (map.make #uint32T #uint64T) in
     struct.make #bucket [{
       "mu" ::= "$mu";
       "subMap" ::= "$subMap"
     }]))).

Definition createNewBuckets : go_string := "sys_verif_code/sharded_hashmap.createNewBuckets"%go.

(* go: sharded_hashmap.go:47:6 *)
Definition createNewBucketsⁱᵐᵖˡ : val :=
  λ: "newSize",
    exception_do (let: "newSize" := (mem.alloc "newSize") in
    let: "newBuckets" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := #slice.nil in
    do:  ("newBuckets" <-[#sliceT] "$r0");;;
    let: "numBuckets" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (u_to_w64 (![#uint32T] "newSize")) in
    do:  ("numBuckets" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "numBuckets")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#sliceT] "newBuckets") in
      let: "$a1" := ((let: "$sl0" := ((func_call #newBucket) #()) in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("newBuckets" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "newBuckets")).

Definition NewHashMap : go_string := "sys_verif_code/sharded_hashmap.NewHashMap"%go.

(* NewHashMap creates a hashmap with size buckets.

   Larger size will consume some memory for the additional locks, but will
   improve concurrency by reducing the number of hash collisions.

   go: sharded_hashmap.go:60:6 *)
Definition NewHashMapⁱᵐᵖˡ : val :=
  λ: "size",
    exception_do (let: "size" := (mem.alloc "size") in
    return: (mem.alloc (let: "$buckets" := (let: "$a0" := (![#uint32T] "size") in
     (func_call #createNewBuckets) "$a0") in
     struct.make #HashMap [{
       "buckets" ::= "$buckets"
     }]))).

Definition bucketIdx : go_string := "sys_verif_code/sharded_hashmap.bucketIdx"%go.

(* go: sharded_hashmap.go:66:6 *)
Definition bucketIdxⁱᵐᵖˡ : val :=
  λ: "key" "numBuckets",
    exception_do (let: "numBuckets" := (mem.alloc "numBuckets") in
    let: "key" := (mem.alloc "key") in
    return: (u_to_w64 ((let: "$a0" := (![#uint32T] "key") in
     (func_call #hash) "$a0") `rem` (u_to_w32 (![#uint64T] "numBuckets"))))).

(* Load gets a key from the map and returns (v, ok). If ok is false then the key
   was not found.

   go: sharded_hashmap.go:72:20 *)
Definition HashMap__Loadⁱᵐᵖˡ : val :=
  λ: "hm" "key",
    exception_do (let: "hm" := (mem.alloc "hm") in
    let: "key" := (mem.alloc "key") in
    let: "buckets" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #HashMap #"buckets"%go (![#ptrT] "hm"))) in
    do:  ("buckets" <-[#sliceT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "buckets") (let: "$a0" := (![#uint32T] "key") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "buckets") in
    slice.len "$a0")) in
    (func_call #bucketIdx) "$a0" "$a1"))) in
    do:  ("b" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #bucket #"mu"%go (![#ptrT] "b")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint32T #uint64T] (struct.field_ref #bucket #"subMap"%go (![#ptrT] "b"))) (![#uint32T] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #bucket #"mu"%go (![#ptrT] "b")))) #());;;
    return: (![#uint64T] "x", ![#boolT] "ok")).

(* Store inserts a key into the map.

   go: sharded_hashmap.go:82:20 *)
Definition HashMap__Storeⁱᵐᵖˡ : val :=
  λ: "hm" "key" "val",
    exception_do (let: "hm" := (mem.alloc "hm") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "buckets" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #HashMap #"buckets"%go (![#ptrT] "hm"))) in
    do:  ("buckets" <-[#sliceT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "buckets") (let: "$a0" := (![#uint32T] "key") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "buckets") in
    slice.len "$a0")) in
    (func_call #bucketIdx) "$a0" "$a1"))) in
    do:  ("b" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #bucket #"mu"%go (![#ptrT] "b")))) #());;;
    let: "$r0" := (![#uint64T] "val") in
    do:  (map.insert (![type.mapT #uint32T #uint64T] (struct.field_ref #bucket #"subMap"%go (![#ptrT] "b"))) (![#uint32T] "key") "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #bucket #"mu"%go (![#ptrT] "b")))) #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(hash, hashⁱᵐᵖˡ); (newBucket, newBucketⁱᵐᵖˡ); (createNewBuckets, createNewBucketsⁱᵐᵖˡ); (NewHashMap, NewHashMapⁱᵐᵖˡ); (bucketIdx, bucketIdxⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(entry.id, []); (ptrT.id entry.id, []); (entryShard.id, []); (ptrT.id entryShard.id, [("Get"%go, entryShard__Getⁱᵐᵖˡ); ("Store"%go, entryShard__Storeⁱᵐᵖˡ)]); (bucket.id, []); (ptrT.id bucket.id, []); (HashMap.id, []); (ptrT.id HashMap.id, [("Load"%go, HashMap__Loadⁱᵐᵖˡ); ("Store"%go, HashMap__Storeⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo sharded_hashmap.sharded_hashmap :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #sharded_hashmap.sharded_hashmap (λ: <>,
      exception_do (do:  (sync.initialize' #());;;
      do:  (package.alloc sharded_hashmap.sharded_hashmap #()))
      ).

End code.
End sharded_hashmap.
