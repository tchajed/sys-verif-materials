(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.sys_verif_code.hashmap.

Set Default Proof Using "Type".

Module hashmap.
Module atomicPtr.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance atomicPtr_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (hashmap.atomicPtr.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(hashmap.atomicPtr.t), "mu"] ↦{dq} v.(hashmap.atomicPtr.mu') ∗
      "val" ∷ l.[(hashmap.atomicPtr.t), "val"] ↦{dq} v.(hashmap.atomicPtr.val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance atomicPtr_into_val_typed
   :
  IntoValTypedUnderlying (hashmap.atomicPtr.t) (hashmap.atomicPtrⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance atomicPtr_access_load_mu l (v : (hashmap.atomicPtr.t)) dq :
  AccessStrict
    (l.[(hashmap.atomicPtr.t), "mu"] ↦{dq} (v.(hashmap.atomicPtr.mu')))
    (l.[(hashmap.atomicPtr.t), "mu"] ↦{dq} (v.(hashmap.atomicPtr.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance atomicPtr_access_store_mu l (v : (hashmap.atomicPtr.t)) mu' :
  AccessStrict
    (l.[(hashmap.atomicPtr.t), "mu"] ↦ (v.(hashmap.atomicPtr.mu')))
    (l.[(hashmap.atomicPtr.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(hashmap.atomicPtr.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance atomicPtr_access_load_val l (v : (hashmap.atomicPtr.t)) dq :
  AccessStrict
    (l.[(hashmap.atomicPtr.t), "val"] ↦{dq} (v.(hashmap.atomicPtr.val')))
    (l.[(hashmap.atomicPtr.t), "val"] ↦{dq} (v.(hashmap.atomicPtr.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance atomicPtr_access_store_val l (v : (hashmap.atomicPtr.t)) val' :
  AccessStrict
    (l.[(hashmap.atomicPtr.t), "val"] ↦ (v.(hashmap.atomicPtr.val')))
    (l.[(hashmap.atomicPtr.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(hashmap.atomicPtr.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End atomicPtr.

Module HashMap.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance HashMap_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (hashmap.HashMap.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "clean" ∷ l.[(hashmap.HashMap.t), "clean"] ↦{dq} v.(hashmap.HashMap.clean') ∗
      "mu" ∷ l.[(hashmap.HashMap.t), "mu"] ↦{dq} v.(hashmap.HashMap.mu') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance HashMap_into_val_typed
   :
  IntoValTypedUnderlying (hashmap.HashMap.t) (hashmap.HashMapⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance HashMap_access_load_clean l (v : (hashmap.HashMap.t)) dq :
  AccessStrict
    (l.[(hashmap.HashMap.t), "clean"] ↦{dq} (v.(hashmap.HashMap.clean')))
    (l.[(hashmap.HashMap.t), "clean"] ↦{dq} (v.(hashmap.HashMap.clean')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HashMap_access_store_clean l (v : (hashmap.HashMap.t)) clean' :
  AccessStrict
    (l.[(hashmap.HashMap.t), "clean"] ↦ (v.(hashmap.HashMap.clean')))
    (l.[(hashmap.HashMap.t), "clean"] ↦ clean')
    (l ↦ v) (l ↦ (v <|(hashmap.HashMap.clean') := clean'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HashMap_access_load_mu l (v : (hashmap.HashMap.t)) dq :
  AccessStrict
    (l.[(hashmap.HashMap.t), "mu"] ↦{dq} (v.(hashmap.HashMap.mu')))
    (l.[(hashmap.HashMap.t), "mu"] ↦{dq} (v.(hashmap.HashMap.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HashMap_access_store_mu l (v : (hashmap.HashMap.t)) mu' :
  AccessStrict
    (l.[(hashmap.HashMap.t), "mu"] ↦ (v.(hashmap.HashMap.mu')))
    (l.[(hashmap.HashMap.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(hashmap.HashMap.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End HashMap.

End hashmap.
