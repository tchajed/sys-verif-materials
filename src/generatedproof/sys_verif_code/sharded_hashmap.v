(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.sys_verif_code.sharded_hashmap.

Set Default Proof Using "Type".

Module sharded_hashmap.
Module entry.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sharded_hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance entry_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sharded_hashmap.entry.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "key" ∷ l.[(sharded_hashmap.entry.t), "key"] ↦{dq} v.(sharded_hashmap.entry.key') ∗
      "val" ∷ l.[(sharded_hashmap.entry.t), "val"] ↦{dq} v.(sharded_hashmap.entry.val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance entry_into_val_typed
   :
  IntoValTypedUnderlying (sharded_hashmap.entry.t) (sharded_hashmap.entryⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance entry_access_load_key l (v : (sharded_hashmap.entry.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.entry.t), "key"] ↦{dq} (v.(sharded_hashmap.entry.key')))
    (l.[(sharded_hashmap.entry.t), "key"] ↦{dq} (v.(sharded_hashmap.entry.key')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance entry_access_store_key l (v : (sharded_hashmap.entry.t)) key' :
  AccessStrict
    (l.[(sharded_hashmap.entry.t), "key"] ↦ (v.(sharded_hashmap.entry.key')))
    (l.[(sharded_hashmap.entry.t), "key"] ↦ key')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.entry.key') := key'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance entry_access_load_val l (v : (sharded_hashmap.entry.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.entry.t), "val"] ↦{dq} (v.(sharded_hashmap.entry.val')))
    (l.[(sharded_hashmap.entry.t), "val"] ↦{dq} (v.(sharded_hashmap.entry.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance entry_access_store_val l (v : (sharded_hashmap.entry.t)) val' :
  AccessStrict
    (l.[(sharded_hashmap.entry.t), "val"] ↦ (v.(sharded_hashmap.entry.val')))
    (l.[(sharded_hashmap.entry.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.entry.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End entry.

Module entryShard.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sharded_hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance entryShard_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sharded_hashmap.entryShard.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "entries" ∷ l.[(sharded_hashmap.entryShard.t), "entries"] ↦{dq} v.(sharded_hashmap.entryShard.entries') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance entryShard_into_val_typed
   :
  IntoValTypedUnderlying (sharded_hashmap.entryShard.t) (sharded_hashmap.entryShardⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance entryShard_access_load_entries l (v : (sharded_hashmap.entryShard.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.entryShard.t), "entries"] ↦{dq} (v.(sharded_hashmap.entryShard.entries')))
    (l.[(sharded_hashmap.entryShard.t), "entries"] ↦{dq} (v.(sharded_hashmap.entryShard.entries')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance entryShard_access_store_entries l (v : (sharded_hashmap.entryShard.t)) entries' :
  AccessStrict
    (l.[(sharded_hashmap.entryShard.t), "entries"] ↦ (v.(sharded_hashmap.entryShard.entries')))
    (l.[(sharded_hashmap.entryShard.t), "entries"] ↦ entries')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.entryShard.entries') := entries'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End entryShard.

Module bucket.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sharded_hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance bucket_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sharded_hashmap.bucket.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(sharded_hashmap.bucket.t), "mu"] ↦{dq} v.(sharded_hashmap.bucket.mu') ∗
      "subMap" ∷ l.[(sharded_hashmap.bucket.t), "subMap"] ↦{dq} v.(sharded_hashmap.bucket.subMap') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance bucket_into_val_typed
   :
  IntoValTypedUnderlying (sharded_hashmap.bucket.t) (sharded_hashmap.bucketⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance bucket_access_load_mu l (v : (sharded_hashmap.bucket.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.bucket.t), "mu"] ↦{dq} (v.(sharded_hashmap.bucket.mu')))
    (l.[(sharded_hashmap.bucket.t), "mu"] ↦{dq} (v.(sharded_hashmap.bucket.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance bucket_access_store_mu l (v : (sharded_hashmap.bucket.t)) mu' :
  AccessStrict
    (l.[(sharded_hashmap.bucket.t), "mu"] ↦ (v.(sharded_hashmap.bucket.mu')))
    (l.[(sharded_hashmap.bucket.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.bucket.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance bucket_access_load_subMap l (v : (sharded_hashmap.bucket.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.bucket.t), "subMap"] ↦{dq} (v.(sharded_hashmap.bucket.subMap')))
    (l.[(sharded_hashmap.bucket.t), "subMap"] ↦{dq} (v.(sharded_hashmap.bucket.subMap')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance bucket_access_store_subMap l (v : (sharded_hashmap.bucket.t)) subMap' :
  AccessStrict
    (l.[(sharded_hashmap.bucket.t), "subMap"] ↦ (v.(sharded_hashmap.bucket.subMap')))
    (l.[(sharded_hashmap.bucket.t), "subMap"] ↦ subMap')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.bucket.subMap') := subMap'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End bucket.

Module HashMap.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sharded_hashmap.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance HashMap_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sharded_hashmap.HashMap.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "buckets" ∷ l.[(sharded_hashmap.HashMap.t), "buckets"] ↦{dq} v.(sharded_hashmap.HashMap.buckets') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance HashMap_into_val_typed
   :
  IntoValTypedUnderlying (sharded_hashmap.HashMap.t) (sharded_hashmap.HashMapⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance HashMap_access_load_buckets l (v : (sharded_hashmap.HashMap.t)) dq :
  AccessStrict
    (l.[(sharded_hashmap.HashMap.t), "buckets"] ↦{dq} (v.(sharded_hashmap.HashMap.buckets')))
    (l.[(sharded_hashmap.HashMap.t), "buckets"] ↦{dq} (v.(sharded_hashmap.HashMap.buckets')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HashMap_access_store_buckets l (v : (sharded_hashmap.HashMap.t)) buckets' :
  AccessStrict
    (l.[(sharded_hashmap.HashMap.t), "buckets"] ↦ (v.(sharded_hashmap.HashMap.buckets')))
    (l.[(sharded_hashmap.HashMap.t), "buckets"] ↦ buckets')
    (l ↦ v) (l ↦ (v <|(sharded_hashmap.HashMap.buckets') := buckets'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End HashMap.

End sharded_hashmap.
